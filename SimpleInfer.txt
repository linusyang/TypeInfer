======
Syntax
======

e ::= n | x | e1 + e2 | \x . e | \x : t . e | e1 e2

t ::= ~x | Int | t1 -> t2

T ::=  | T, x | T, x : t 

======
Typing
======

==========
T |- e => t -| U
T |- e <= t -| U
==========

T |- n => Int -| T

T |- e1 <= Int -| X      X |- e2 <= Int -| Y
------------------------------------
T |- e1 + e2 => Int -| Y

T, x : t1 |- e <= t2 -| X, x : t1, Y      
-----------------------------
T |- \x . e <= t1 -> t2 -| X 

T, x |- e => t2 -| X, x : t1, Y
-------------------------- (if we get X, x, Y then ask user to annotate x) 
T |- \x . e => t1 -> t2 -| X 

T, x : t1 |- e => t2 -| X, x : t1, Y      
----------------------------
T |- \x : t1. e => t1 -> t2 -| X 

T |- e1 => t1 -> t2 -| X        X |- e2 <= t1 -| Y
------------------------------------------
T |- e1 e2 => t2 -| Y

x:t \in T
-----------------
T |-  x => t  -| T

--------------------------
T, x, Y |- x <= t  -| T [~x -> t], x : t, Y[~x -> t]

x \in T
--------------- (Special rule, creates a "unification variable")
T |- x => ~x  -| T

Need to flip modes?

T |- e => t
---------- ???
T |- e <= t

More rules:

T |- e2 => t1 -| X      X |- e1 <= t1 -> t2 -| Y        
-----------------------------------------
T |- e1 e2 <= t2 -| Y


Tests:

x |- x <= Int -| x:Int          x:Int |- 1 <= Int -| x:Int 
----------------------------------------------
x |- x + 1 => Int -| x : Int
------------------------
|- \x . x+1 => Int -> Int -|




g,x |- x => ~x -| g,x          g,x |- g <= ~x -> Int -| g : ~x -> Int,x
-------------------------------------------------
g, x |- g x <= Int -| g : ~x -> Int, x     ... |- x <= Int -| g : Int-> Int, x:Int
----------------------------------------------------------------
g, x |- g x + x -| g : Int-> Int, x:Int
---------------------------------------
|- \g \x . g x + x => (Int -> Int) -> Int -> Int -|
