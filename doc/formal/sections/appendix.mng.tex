\section{type check}

\subsection{Syntax}

Expressions and types have the same form. Compared to original type system which $\forall$ variables are of type $\star$, here are type annotatios in $\forall$ which can be other types. \\

\gram{\otte\ottinterrule}

Originally the definitions in the paper are\\

$\rho = \tau\ |\ \sigma \to \sigma$

$\tau = Int\ |\ \tau_1 \to \tau_2\ |\ a$
\\[2.0mm]

Here are some obversations:

1. $\rho$ have arrow type ranges over $\sigma$.

2. $\rho$ contains $\tau$.

3. There will be no $\forall$ in $\tau$. The understanding of this is because monotype $\tau$ is what can be omitted in the lambda annotations and will be inferred in the type inference algorithm.\\

To keep 1 and 2 true will be easy but it need to be careful to keep 3 true. Because the new type system will have more forms of types. For example an annotated expression $(\forall a. a \to a):\star$. It is not a $\sigma$ but it do contain $\sigma$. The solution is to select carefullly to keep $\tau$ away from $\forall$. \\

\gram{\ottR\ottinterrule}

\gram{ \ottt\ottinterrule}


%\subsection{Type-preserving substitution}

\newcommand{\tpmapsto}[3]{#2\mapsto#3}

%A type-preserving substitution $\tpmapsto \sigma {e_1} {e_2}$ means substitute $e_2$ for $e_1$ where $e_1$ and $e_2$ are of same type $\sigma$.

%Sometimes $\sigma$ will be omitted if $e_1$ and $e_2$ are obviously of the same type.

\subsection{Operational Semantics: Call by name}

\newcommand{\castupe}{\ensuremath{\mathsf{cast}^{\uparrow}\ }}
\newcommand{\castdowne}{\ensuremath{\mathsf{cast}^{\downarrow}\ }}

This section is about $\beta-$reduction on types. They will be used in \castupe and \castdowne.
\[
\inferrule*[right=S-Beta]
{  }
{ (\lambda x. e_1) e_2 \longrightarrow e_1 [x\mapsto e_2] }
\]

\[
\inferrule*[right=S-BetaAnn]
{  }
{ (\lambda x:\sigma. e_1) e_2 \longrightarrow e_1 [x\mapsto e_2] }
\]

\[
\inferrule*[right=S-App]
{ e_1 \longrightarrow e_1'  }
{ e_1 e_2 \longrightarrow e_1' e_2}
\]

\[
\inferrule*[right=S-CastDownUp]
{  }
{ \castdowne (\castupe e)  \longrightarrow e }
\]

\[
\inferrule*[right=S-CastDown]
{ e \longrightarrow e' }
{ \castdowne  e  \longrightarrow  \castdowne  e' }
\]

\[
\inferrule*[right=S-Ann]
{ e \longrightarrow e'  }
{ e:\sigma \longrightarrow e':\sigma}
\]

\[
\inferrule*[right=S-Let]
{  }
{ let\ x = e_1\ in\ e_2 \longrightarrow e_2[x\mapsto e_1] }
\]

\subsection{Specification of Typing}

\newcommand{\judge}{\Gamma\vdash}
\newcommand{\forallvars}[1]{\forall \overbar{#1}}
\newcommand{\olpolymorphic}[2]{\vdash^{ol} #1 \sqsubseteq #2}

\framebox{$ \judge e : \sigma$ }

$\star$ is the type of all types including itself.

\[
\hl{$
\inferrule*[right=Ax]
{} {\judge \star : \star}
$}
\]

\[
\inferrule*[right=Var]
{x : \sigma \in \Gamma} {\judge x : \sigma}
\]

\[
\inferrule*[right=Lam]
{\Gamma,x: \tau \vdash e : \sigma } {\judge (\lambda x.\, e) : (\Pi x: \tau. \sigma)}
\]

Annotation must have type $\star$.

\[
\inferrule*[right=LamAnn]
{ \hl{$\judge \sigma: \star$} \\
\Gamma,x: \sigma \vdash e : \sigma_2 } {\judge (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \sigma_2)}
\]

Because $x$ may appear in $e_1$ so there will be a substitution in $e_2$.

\[
\inferrule*[right=App]
{\judge e_1 : (\Pi x:\sigma_1. \sigma_2) \\ \judge e_2 : \sigma_1} {\judge e_1\,e_2 : \sigma_2\hl{$[\tpmapsto {\sigma_1} x {e_2}]$}}
\]

Annotation must have type $\star$.

\[
\inferrule*[right=Ann]
{\hl{$\judge \sigma: \star$}\\
\judge e : \sigma }
{\judge (e :: \sigma) : \sigma }
\]

Typing rules for cast is the application of operational semantic.

\[
\hl{$
\inferrule*[right=CastUp]
{\judge e : \rho \\ \judge \sigma : \star \\ \rho \longrightarrow \sigma} {\judge (\mathsf{cast}^\uparrow\ e) : \sigma}
$}
\]

\[
\hl{$
\inferrule*[right=CastDown]
{\judge e : \rho \\ \judge \sigma : \star \\ \rho \longrightarrow \sigma} {\judge (\mathsf{cast}_\downarrow\ e) : \sigma}
$}
\]

Let will use substitution strategy becuase not only the type of $x$ but also what $x$ is will be important since it will be used in $e_2$.

\[
\inferrule*[right=Let]
{\judge e_1 : \sigma_1 \\ \Gamma \vdash e_2\hl{$[\tpmapsto {\sigma_1} x {e_1}]$}: \sigma_2} {\judge ( let\ x = e_1\ in\ e_2 ) : \sigma_2 }
\]

Pi is of type $\star$.

\[
\hl{$
\inferrule*[right=ImplicitPi]
{\judge \overbar{\tau} : \star \\ \Gamma, \overbar{x:\tau} \vdash \rho : \star} {\judge (\forallvars{x : \tau}. \rho) : \star}
$}
\]

\[
\hl{$
\inferrule*[right=ExplicitPi]
{\judge \sigma_1 : \star \\ \Gamma, x:\sigma_1 \vdash \sigma_2 : \star} {\judge (\Pi x:\sigma_1. \sigma_2) : \star}
$}
\]

Because the variables in $\forall$ can have types other than $\star$, so we need to check the annotations and make sure it is valid.

\[
\inferrule*[right=Gen]
{\judge e : \rho \\
\alpha_i \notin ftv(\Gamma) \\
\hl{$\tau_i : \star$} \\
\hl{$\alpha_i : \tau_i \vdash \sigma : \star$}}
{\judge e : \forall(\alpha_i : \tau_i). \rho }
\]

\[
\inferrule*[right=Subs]
{\judge e : \sigma \\ \olpolymorphic{\sigma} {\sigma'}} {\judge e : \sigma' }
\]

\framebox{$ \olpolymorphic \sigma {\sigma'}$ }

\[
\inferrule*[right=Skol]
{
\overbar{a} \notin ftv(\sigma)\\
\olpolymorphic \sigma \rho \\
}
{\olpolymorphic \sigma {\forallvars{a:\tau}.\rho}}
\]

Substitution must be type-preserving.

\[
\inferrule*[right=Spec]
{\hl{$\overbar{b: \tau}$} \\
\olpolymorphic {\rho_1[\overbar{\tpmapsto \tau a b}]} {\rho_2}}
{\olpolymorphic {\forallvars{a:\tau}.\rho_1} {\rho_2}}
\]

\[
\inferrule*[right=Fun]
{\olpolymorphic  {\sigma_3} {\sigma_1} \\
\olpolymorphic  {\sigma_2} {\rho_4}}
{ \olpolymorphic {\Pi x:\sigma_1. \sigma_2} {\Pi x:\sigma_3. \rho_4}}
\]

Instead of Mono, we will use $\alpha-$equal to compare two identical types.

\[
\hl{$
\inferrule*[right=Alpha-Equal]
{  \alpha-equal(\sigma_1, \sigma_2)  }
{ \olpolymorphic {\sigma_1} {\sigma_2}}
$}
\]

In application, the arguments are required to be identical and the lambda need to be polymorphic.

Polymorphism on Lam is just the relationship on its body. In LamAnn the annotations are also required to be identical.

\[
\hl{$
\inferrule*[right=App]
{
\olpolymorphic {\tau_1} {\tau_2}
}
{\olpolymorphic {\tau_1\, \sigma_1} {\tau_2\, \sigma_1} \\
}
$}
\]

\[
\hl{$
\inferrule*[right=Lam]
{
\olpolymorphic {\sigma_1} {\sigma_2}}
{\olpolymorphic {\lambda x. \sigma_1} {\lambda x. \sigma_2 }}
$}
\]


\[
\hl{$
\inferrule*[right=Lamann]
{
\olpolymorphic {\sigma_2}{\sigma_4}}
{\olpolymorphic {\lambda x:\sigma_1. \sigma_2} {\lambda x:\sigma_1. \sigma_4}
}
$}
\]

The annotations need to be identical.

\[
\hl{$
\inferrule*[right=Ann]
{
\olpolymorphic {\sigma_1} {\sigma_3 }}
{\olpolymorphic {\sigma_1:\sigma_2} {\sigma_3:\sigma_2 }}
$}
\]

In Cast, continue to compare the casted expressions.

\[
\hl{$
\inferrule*[right=Castup]
{
\olpolymorphic {\sigma_1} {\sigma_2}}
{\olpolymorphic {(\castupe \sigma_1)} {(\castupe \sigma_2) }}
$}
\]

\[
\hl{$
\inferrule*[right=Castdown]
{
 \olpolymorphic {\sigma_1} {\sigma_2}}
 { \olpolymorphic {(\castdowne \sigma_1)} {(\castdowne \sigma_2)}}
$}
\]

In Let, $e_1$ need to be identical and than compare the body.

\[
\hl{$
\inferrule*[right=Let]
{
\olpolymorphic {\sigma_1} {\sigma_2 }}
{\olpolymorphic {(let\ x = e_1\ in\ \sigma_1)} {(let\ x = e_1\ in\ \sigma_2) }}
$}
\]


\clearpage

\subsection{syntax-directed Typing}

\newcommand{\checktype}{\Gamma\vdash_\Downarrow}
\newcommand{\infertype}{\Gamma\vdash_\Uparrow}
\newcommand{\infercheck}{\Gamma\vdash_\delta}

\newcommand{\checktypeno}{\vdash_\Downarrow}
\newcommand{\infertypeno}{\vdash_\Uparrow}
\newcommand{\infercheckno}{\vdash_\delta}

\newcommand{\instinfer}{\vdash^{inst}_\Uparrow}
\newcommand{\instcheck}{\vdash^{inst}_\Downarrow}
\newcommand{\instinfercheck}{\vdash^{inst}_\delta}

\newcommand{\polyinfer}{\Gamma\vdash^{poly}_\Uparrow}
\newcommand{\polycheck}{\Gamma\vdash^{poly}_\Downarrow}
\newcommand{\polycheckno}{\vdash^{poly}_\Downarrow}
\newcommand{\polyinfercheck}{\vdash^{poly}_\delta}

\newcommand{\polymorphic}{\vdash^{dsk}}
\newcommand{\polymorphicstar}{\vdash^{dsk\star}}



\framebox{$ \infercheck e : \rho$ } infer $\Uparrow$ check $\Downarrow$ $\delta = \Uparrow \mid \Downarrow$

\[
\hl{$
\inferrule*[right=AX]
{} {\infercheck \star : \star}
$}
\]

\[
\inferrule*[right=Var]
{x:\sigma \in \Gamma \\ \instinfercheck \sigma \sqsubseteq \rho } {\infercheck x : \rho}
\]

\[
\inferrule*[right=Lam-Infer]
{\Gamma,x: \tau \infertypeno e : \rho} {\infertype (\lambda x.\, e) : (\Pi x: \tau. \rho)}
\]

\[
\inferrule*[right=Lam-Check]
{\Gamma,x: \sigma_1 \polycheckno e : \sigma_2 } {\checktype (\lambda x.\, e) : (\Pi x: \sigma_1. \sigma_2)}
\]

\[
\inferrule*[right=LamAnn-Infer]
{
\hl{$\checktype \sigma:\star$} \\
\Gamma,x: \sigma \infertypeno e : \rho } {\infertype (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \rho)}
\]

\[
\inferrule*[right=LamAnn-Check]
{
\hl{$\checktype \sigma:\star$} \\
\polymorphic \sigma_1 \sqsubseteq \sigma \\ \Gamma,x: \sigma \polycheckno e : \sigma_2 } {\checktype (\lambda x:\sigma.\, e) : (\Pi x: \sigma_1. \sigma_2)}
\]

\[
\inferrule*[right=App]
{\infertype e_1 : (\Pi x:\sigma_1. \sigma_2) \\
\polycheck e_2 : \sigma_1 \\
\instinfercheck \hl{$\sigma_2 [\tpmapsto {\sigma_1} x {e_2}]$} \sqsubseteq \rho}
{\infercheck e_1\,e_2 : \rho}
\]

\[
\inferrule*[right=Ann]
{
\hl{$\checktype \sigma : \star$} \\
\polycheck (e:\sigma) \\
\instinfercheck \sigma : \rho }
{\infercheck (e : \sigma) : \rho }
\]

\[
\hl{$
\inferrule*[right=CastUp-Check]
{ \rho \longrightarrow \sigma \\ \polycheck e : \sigma } {\checktype (\castupe e) : \rho}
$}
\]

\[
\hl{$
\inferrule*[right=CastDown]
{\infertype e : \rho_1 \\ \rho_1 \longrightarrow \sigma \\ \instinfercheck \sigma \sqsubseteq \rho_2} {\infercheck (\castdowne e) : \rho_2}
$}
\]

\[
\inferrule*[right=Let]
{\polyinfer e_1 : \sigma \\
\hl{$\infercheck e_2[\tpmapsto {\sigma} x {e_1}]: \rho$}}
{\infercheck ( let\ x = e_1\ in\ e_2 ) : \rho }
\]

\[
\hl{$
\inferrule*[right=ImplicitPi]
{\checktype \tau : \star \\ \Gamma, x:\tau \checktypeno \rho : \star} {\infercheck (\forall x : \tau. \rho) : \star}
$}
\]

\[
\hl{$
\inferrule*[right=ExplicitPi]
{\checktype \sigma_1 : \star \\ \Gamma, x:\sigma_1 \checktypeno \sigma_2 : \star} {\infercheck (\Pi x : \sigma_1. \sigma_2) : \star}
$}
\]

\framebox{$ \Gamma \polyinfercheck e : \sigma$ }

\[
\inferrule*[right=Gen-Infer]
{\infertype e :\rho \\ \overbar{\hl{$x:\tau$}}=ftv(\rho)-ftv(\Gamma) \\
\hl{$\checktype (\forallvars{x:\tau}. \rho):\star$} } {\polyinfer e :(\forallvars{x:\tau}. \rho)}
\]

\[
\inferrule*[right=Gen-Check]
{
pr(\sigma) = \forallvars{\hl{$x:\tau$}}. \rho \\
\overbar{\hl{$x:\tau$}} \notin ftv(\Gamma) \\
\checktype e :\rho
} {\polycheck e : \sigma}
\]

\framebox{$ \instinfercheck \sigma \sqsubseteq \rho$ }

\[
\inferrule*[right=Inst-Infer]
{\hl{$\overbar{\tau_\beta : \tau}$}}
{\instinfer \forallvars{x:\tau}. \rho \sqsubseteq \rho[\overbar{\tpmapsto {\tau} x {\tau_\beta}}]}
\]

\[
\inferrule*[right=Inst-Check]
{\polymorphic \sigma \sqsubseteq \rho } {\instcheck \sigma \sqsubseteq \rho}
\]

\framebox{$pr(\sigma)=\forallvars{x:\tau}.\rho$}

\[
\inferrule*[right=Pr-poly]
{pr(\rho_1) = \forallvars{b:\tau_2}. \rho_2 \\ \overbar{a} \cap \overbar{b} = \emptyset} {pr(\forallvars{a:\tau_1}. \rho_1) = \forallvars{a:\tau_1. b:\tau_2}. \rho_2}
\]

\[
\inferrule*[right=Pr-fun]
{pr(\sigma_2) = \forallvars{a:\tau}. \rho_2 \\ \overbar{a} \cap ftv(\sigma_1) = \emptyset} {pr(\Pi x:\sigma_1. \sigma_2) = \forallvars{a:\tau}. \Pi x:\sigma_1. \rho_2}
\]

\[
\inferrule*[right=\hl{Pr-other-case}]
{  } {pr(\tau)=\tau}
\]

\framebox{$\polymorphic \sigma_1 \sqsubseteq \sigma_2$}

\[
\inferrule*[right=Deep-skol]
{pr(\sigma_2)=\forallvars{a:\tau}. \rho \\ a \notin ftv(\sigma_1) \\
\polymorphicstar \sigma_1 \sqsubseteq \rho }
{\polymorphic \sigma_1 \sqsubseteq \sigma_2}
\]

\framebox{$\sigma_1 \sqsubseteq \rho$}

\[
\hl{$
\inferrule*[right=Alpha-Equal]
{  \alpha-equal(\sigma_1, \sigma_2)  }
{ \Sigma \polymorphicstar \sigma_1 \sqsubseteq \sigma_2 }
$}
\]

\[
\inferrule*[right=Spec]
{\hl{$\overbar{b: \tau}$} \\
\polymorphicstar \rho_1[\overbar{\tpmapsto \tau a b}] \sqsubseteq \rho_2}
{\Sigma \polymorphicstar \forallvars{a:\tau}.\rho_1 \sqsubseteq \rho_2}
\]

\[
\inferrule*[right=Fun]
{\polymorphic  \sigma_3 \sqsubseteq \sigma_1 \\
\polymorphicstar  \sigma_2 \sqsubseteq \rho_4}
{ \polymorphicstar \Pi x:\sigma_1. \sigma_2 \sqsubseteq \Pi x:\sigma_3. \rho_4}
\]

\[
\hl{$
\inferrule*[right=App]
{
\polymorphicstar \tau_1 \sqsubseteq \tau_2
}
{\polymorphicstar \tau_1\, \sigma_1 \sqsubseteq \tau_2\, \sigma_1 \\
}
$}
\]

\[
\hl{$
\inferrule*[right=Lam]
{
\polymorphic \sigma_1 \sqsubseteq \sigma_2 }
{\polymorphicstar \lambda x. \sigma_1 \sqsubseteq \lambda x. \sigma_2 }
$}
\]


\[
\hl{$
\inferrule*[right=Lamann]
{
\polymorphic \sigma_2 \sqsubseteq \sigma_4 }
{\polymorphicstar \lambda x:\sigma_1. \sigma_2 \sqsubseteq \lambda x:\sigma_1. \sigma_4
}
$}
\]

\[
\hl{$
\inferrule*[right=Ann]
{
 \polymorphic  \sigma_1 \sqsubseteq \sigma_3 }
{\polymorphicstar \sigma_1:\sigma_2 \sqsubseteq \sigma_3:\sigma_2 }
$}
\]

\[
\hl{$
\inferrule*[right=Castup]
{
\polymorphic  \sigma_1 \sqsubseteq \sigma_2 }
{\polymorphicstar  (\castupe \sigma_1) \sqsubseteq  (\castupe \sigma_2) }
$}
\]

\[
\hl{$
\inferrule*[right=Castdown]
{
 \polymorphic  \sigma_1 \sqsubseteq \sigma_2 }
{ \polymorphicstar  (\castdowne \sigma_1) \sqsubseteq  (\castdowne \sigma_2)}
$}
\]

\[
\hl{$
\inferrule*[right=Let]
{
 \polymorphic  \sigma_1 \sqsubseteq \sigma_2 }
{ \polymorphicstar  (let\ x = e_1\ in\ \sigma_1) \sqsubseteq  (let\ x = e_1\ in\ \sigma_2) }
$}
\]

\clearpage

\subsection{Unification}

\begin{algorithm}
\caption{Unification}\label{euclid}
\begin{algorithmic}[1]
\algloopdefx{Let}[1]{\textbf{Let} #1 \textbf{In}}
\algloop[In]{In}
\Function{Unify(C)}{}
\If {C = $\emptyset$}
    \Return []
\Else
    \Let {$\{S=T\} \cup C' = C$}
        \If{$\alpha$-equal S T}
            \State unify($C'$)
        \ElsIf{$S =$ TVar $X$ $K$ and $X \notin FV(T)$ and $T\in \tau$}
            \State $C''$ = checktype $T$ $K$
            \State unify($[\tpmapsto K X T](C \cup C'')) \circ [\tpmapsto K X T]$
        \ElsIf{$T =$ TVar $X$ $K$ and $X \notin FV(S)$ and $S\in \tau$}
            \State $C''$ = checktype $S$ $K$
            \State unify($[\tpmapsto K X S](C \cup C'')) \circ [\tpmapsto K X S]$
        \ElsIf{$S = S_1 \rightarrow S_2$ and $T = T_1 \rightarrow T_2$}
            \State unify($C' \cup \{S_1=T_1, S_2=T_2\}$)
        \ElsIf{$S = cast^\uparrow S_1$ and $T = cast^\uparrow T_1$}
            \State unify($C' \cup \{S_1=T_1\}$)
        \ElsIf{$S = cast^\downarrow S_1$ and $T = cast^\downarrow T_1$}
            \State unify($C' \cup \{S_1=T_1\}$)
        \ElsIf{$S =$ App $S_1$ $S_2$ and $T =$ App $T_1$ $T_2$}
            \State unify($C' \cup \{S_1=T_1, S_2=T_2\}$)
        \ElsIf{$S =$ Ann $S_1$ $S_2$ and $T =$ Ann $T_1$ $T_2$}
            \State unify($C' \cup \{S_1=T_1, S_2=T_2\}$)
        \ElsIf{$S =\lambda x. S_1$  and $T =\lambda x. T_1$}
            \State unify($C' \cup \{S_1=T_1\}$)
        \ElsIf{$S =\lambda x:S_1. S_2$  and $T =\lambda x:T_1. T_2$}
            \State unify($C' \cup \{S_1=T_1, S_2=T_2\}$)
        \Else
            \State fail
        \EndIf
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{Translation}

\newcommand{\transto}[1]{\hl{$\leadsto#1$}}
\newcommand{\translated}[1]{|#1|}
\newcommand{\cyancolorbox}[1]{\colorbox{cyan!30}{$#1$}}
%\newcommand{\invariant}[2]{\leadsto #1 :#2}
\newcommand{\invariant}[2]{}

\subsubsection{Target Language}

\gram{\ottE\ottinterrule}

\subsubsection{Translation Rules}

\framebox{$ \infercheck e : \rho \invariant{E}{|\rho|}$ } infer $\Uparrow$ check $\Downarrow$ $\delta = \Uparrow \mid \Downarrow$

\[
\inferrule*[right=AX]
{} {\infercheck \star : \star \transto{\star}}
\]

\[
\inferrule*[right=Var]
{x:\sigma \in \Gamma \\ \instinfercheck \sigma \sqsubseteq \rho \transto{f} } {\infercheck x : \rho \transto{f\ x}}
\]

\[
\inferrule*[right=Lam-Infer]
{\Gamma,x: \tau \infertypeno e : \rho \transto{E} }
{\infertype (\lambda x.\, e) : (\Pi x: \tau. \rho) \transto {\lambda(x:\translated{\tau}). E}}
\]

\[
\inferrule*[right=Lam-Check]
{\Gamma,x: \sigma_1 \polycheckno e : \sigma_2 \transto{E}
} {\checktype (\lambda x.\, e) : (\Pi x: \sigma_1. \sigma_2) \transto{\lambda(x:\translated{\sigma_1}).E}}
\]

\[
\inferrule*[right=LamAnn-Infer]
{
\checktype \sigma:\star \\
\Gamma,x: \sigma \infertypeno e : \rho \transto{E}
} {\infertype (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \rho) \transto{\lambda(x:\translated{\sigma}). E}}
\]

\[
\inferrule*[right=LamAnn-Check]
{
\checktype \sigma:\star \\
\polymorphic \sigma_1 \sqsubseteq \sigma \transto{f} \\
\Gamma,x: \sigma \polycheckno e : \sigma_2 \transto{E} \\
\cyancolorbox{g = \lambda x:\translated{\sigma_1}. f}
}
{\checktype (\lambda x:\sigma.\, e) : (\Pi x: \sigma_1. \sigma_2) \transto{ \lambda(x:\translated{\sigma_1}). E[\tpmapsto \sigma x {g\ x}] }}
\]

\[
\inferrule*[right=App]
{\infertype e_1 : (\Pi x:\sigma_1. \sigma_2) \transto {E_1} \\
\polycheck e_2 : \sigma_1 \transto{E_2}\\
\instinfercheck \sigma_2 [\tpmapsto {\sigma_1} x e_2] \sqsubseteq \rho \transto{f}}
{\infercheck e_1\,e_2 : \rho \transto{f\ (E_1\ E_2)}}
\]

\[
\inferrule*[right=ExplicitPi]
{\checktype \tau_1 : \star \\ \Gamma, x:\tau_1 \checktypeno \tau_2 : \star }
{\infercheck (\Pi x:\tau_1. \tau_2) : \star \transto{(\Pi x:\translated{\tau_1}. \translated{\tau_2})}}
\]

\[
\inferrule*[right=Ann]
{
\checktype \sigma : \star \\
\polycheck (e:\sigma) \transto{E}\\
\instinfercheck \sigma : \rho \transto{f}}
{\infercheck (e : \sigma) : \rho \transto{f\ E}}
\]

\[
\inferrule*[right=CastUp-Check]
{ \rho \longrightarrow \sigma \\ \polycheck e : \sigma \transto{E} }
{\checktype (\castupe e) : \rho \transto{\castupe [\translated{\rho}]\ E}}
\]

\[
\inferrule*[right=CastDown]
{\infertype e : \rho_1 \transto{E}\\
\rho_1 \longrightarrow \sigma \\
\instinfercheck \sigma \sqsubseteq \rho_2\transto {f}}
{\infercheck (\castdowne e) : \rho_2 \transto {f\ (\castdowne E)}}
\]

\[
\inferrule*[right=Let]
{\polyinfer e_1 : \sigma \transto{E_1}\\
\infercheck e_2[\tpmapsto \sigma x {e_1}]: \rho \transto{E_2}
}
{\infercheck ( let\ x = e_1\ in\ e_2 ) : \rho \transto{(\lambda x:\translated \sigma. E_2)\ E_1}}
\]

\framebox{$ \infercheck \sigma : \star \invariant{E}{*}$ }

\[
\inferrule*[right=ImplicitPi]
{\checktype \tau : \star \\ \Gamma, x:\tau \checktypeno \rho : \star}
{\infercheck (\forall x : \tau. \rho) : \star \transto {\Pi (x:\translated \tau). \translated \rho}}
\]

\framebox{$ \infercheck \rho : \star \invariant{E}{*}$ }

\[
\inferrule*[right=FunPoly]
{\checktype \sigma_1 : \star \\
\Gamma, x:\sigma_1 \checktypeno \sigma_2 : \star }
{\infercheck (\Pi x : \sigma_1. \sigma_2) : \star \transto{\Pi (x:\translated {\sigma_1}). \translated {\sigma_2}}}
\]

\framebox{$ \Gamma \polyinfercheck e : \sigma \invariant{E}{|\sigma|}$ }

\[
\inferrule*[right=Gen-Infer]
{\infertype e :\rho \transto{E} \\ \overbar{x:\tau}=ftv(\rho)-ftv(\Gamma) \\
\checktype (\forallvars{x:\tau}. \rho):\star } {\polyinfer e :(\forallvars{x:\tau}. \rho) \transto{\lambda (\overbar{x:\translated \tau}). E}}
\]

\[
\inferrule*[right=Gen-Check]
{
pr(\sigma) = \forallvars{x:\tau}. \rho \transto{f} \\
\overbar{x:\tau} \notin ftv(\Gamma) \\
\checktype e :\rho \transto{E}
} {\polycheck e : \sigma \transto{f\ (\lambda (\overbar{x:\translated \tau}). E)}}
\]

\framebox{$ \instinfercheck \sigma \sqsubseteq \rho \invariant{f}{|\sigma|\to|\rho|}$ }

\[
\inferrule*[right=Inst-Infer]
{\overbar{y : \tau}
}
{\instinfer \forallvars{x:\tau} . \rho \sqsubseteq \rho[\overbar{\tpmapsto \tau x y}] \transto
{\lambda (a: \translated{\forallvars{x:\tau} . \rho} ). (a\ \translated{\overbar{\tau_{\beta}}})}}
\]

\[
\inferrule*[right=Inst-Check]
{\polymorphic \sigma \sqsubseteq \rho \transto {f} \\
\cyancolorbox{g = \lambda x:\translated{\sigma}. f}
}
{\instcheck \sigma \sqsubseteq \rho \transto {f}}
\]

\framebox{$pr(\sigma)=\forallvars{x:\tau}.\rho \invariant{f}{|\forallvars{x:\tau}.\rho|\to|\sigma|}$}

\[
\inferrule*[right=Pr-poly]
{pr(\rho_1) = \forallvars{b:\tau_2}. \rho_2 \transto{f}\\ \overbar{a} \cap \overbar{b} = \emptyset
}
{pr(\forallvars{a:\tau_1}. \rho_1) = \forallvars{a:\tau_1. b:\tau_2}. \rho_2 \\
\transto{\lambda (x: \translated{\forallvars{a:\tau_1. b:\tau_2}. \rho_2  }).\lambda (\overbar{a:\translated{{\tau_1}}}). f\ (x\ \overbar{a})}}
\]

\[
\inferrule*[right=Pr-fun]
{pr(\sigma_2) = \forallvars{a:\tau}. \rho_2 \transto{f} \\ \overbar{a} \cap ftv(\sigma_1) = \emptyset
}
{pr(\Pi x:\sigma_1. \sigma_2) = \forallvars{a:\tau}. \Pi x:\sigma_1. \rho_2 \\
\transto{\lambda (x:\translated{ \forallvars{a:\tau}. \Pi x:\sigma_1. \rho_2 }). \lambda (y:\translated{\sigma_1}). f\ (\lambda (\overbar{a:\translated{\tau}}). x\ a\ y) }}
\]

\[
\inferrule*[right=Pr-other-case]
{  } {pr(\tau)=\tau \transto {\lambda (x:\translated{\tau}). x}}
\]

\framebox{$\polymorphic \sigma_1 \sqsubseteq \sigma_2 \invariant{f}{|\sigma_1|\to|\sigma_2|}$}

\[
\inferrule*[right=Deep-skol]
{pr(\sigma_2)=\forallvars{a:\tau}. \rho \transto{f_1}\\ a \notin ftv(\sigma_1) \\
\Sigma \vdash \overbar{a:\tau} \\
\Sigma, \overbar{a:\tau} \polymorphicstar \sigma_1 \sqsubseteq \rho \transto{f_2}
}
{\Sigma \polymorphic \sigma_1 \sqsubseteq \sigma_2 \transto{\lambda x:\translated{\sigma_1}. f_1\ (\lambda(\overbar{a:\translated{\tau}}). f_2\ x) }}
\]

\framebox{$\polymorphicstar \sigma \sqsubseteq \rho \invariant{f}{|\sigma| \to|\rho|}$}

\[
\inferrule*[right=Alpha-Equal]
{  \alpha-equal(\sigma_1, \sigma_2)  }
{  \polymorphicstar \sigma_1 \sqsubseteq \sigma_2 \transto{x}}
\]

\[
\inferrule*[right=Spec]
{\overbar{b: \tau} \\
\polymorphicstar \rho_1[\overbar{\tpmapsto \tau a b}] \sqsubseteq \rho_2 \transto{f} \\
\cyancolorbox{ g = \lambda x:\translated{\rho_1[\overbar{\tpmapsto \tau a b}]}. f }
}
{\polymorphicstar \forallvars{a:\tau}.\rho_1 \sqsubseteq \rho_2 \\
\transto {g\ (x\ \translated{\overbar{b}}) }}
\]

\[
\inferrule*[right=Fun]
{\polymorphic  \sigma_3 \sqsubseteq \sigma_1 \transto{f_1} \\
\cyancolorbox{ g_1 = \lambda x:\translated{\sigma_3}. f_1 } \\
\polymorphicstar  \sigma_2[x \mapsto g_1\ y] \sqsubseteq \rho_4 \transto{f_2} \\
\cyancolorbox{ g_2 = \lambda x:\translated{\sigma_2[x \mapsto g_1\ y]}. f_2 }
 }
{ \polymorphicstar \Pi x:\sigma_1. \sigma_2 \sqsubseteq \Pi x:\sigma_3. \rho_4 \\
\transto {\lambda y:\translated{\sigma_3} . g_2\ (x\ (g_1\ y))}
}
\]

\[
\inferrule*[right=App]
{
 \polymorphicstar \tau_1 \sqsubseteq \tau_2 \transto {f}\\
}
{ \polymorphicstar \tau_1\, \sigma_1 \sqsubseteq \tau_2\, \sigma_1 \\
\transto {\castupe \ f[x \mapsto \castdowne x]}}
\]

\[
\inferrule*[right=Lam]
{
 \polymorphic \sigma_1 \sqsubseteq \sigma_2 \transto {f}}
{ \polymorphicstar \lambda x. \sigma_1 \sqsubseteq \lambda x. \sigma_2 \transto {f}}
\]


\[
\inferrule*[right=Lamann]
{
\polymorphic \sigma_2 \sqsubseteq \sigma_4 \transto{f}}
{\polymorphicstar \lambda x:\sigma_1. \sigma_2 \sqsubseteq \lambda x:\sigma_1. \sigma_4 \\
\transto {f}}
\]


\[
\inferrule*[right=Ann]
{
\polymorphic  \sigma_1 \sqsubseteq \sigma_3 \transto{f}}
{\polymorphicstar \sigma_1:\sigma_2 \sqsubseteq \sigma_3:\sigma_2 \transto {f}}
\]

\[
\inferrule*[right=Castup]
{
\polymorphic  \sigma_1 \sqsubseteq \sigma_2 \transto {f}}
{\polymorphicstar  (\castupe \sigma_1) \sqsubseteq  (\castupe \sigma_2) \transto {f}}
\]


\[
\inferrule*[right=Castdown]
{
\polymorphic  \sigma_1 \sqsubseteq \sigma_2 \transto {f}
}
{\polymorphicstar  (\castdowne \sigma_1) \sqsubseteq  (\castdowne \sigma_2)
\transto{ \castupe f[x \mapsto \castdowne x]}}
\]

\[
\inferrule*[right=Let]
{
\polymorphic  \sigma_1 \sqsubseteq \sigma_2 \transto {f}
}
{\polymorphicstar  (let\ x = e_1\ in\ \sigma_1) \sqsubseteq  (let\ x = e_1\ in\ \sigma_2) \\
\transto {\castupe \ f[x \mapsto \castdowne x]}}
\]
