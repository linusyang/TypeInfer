\newcommand{\tpmapsto}[3]{#2\mapsto#3}
\newcommand{\castupe}{\ensuremath{\mathsf{cast}^{\uparrow}\ }}
\newcommand{\castdowne}{\ensuremath{\mathsf{cast}^{\downarrow}\ }}
\newcommand{\judge}{\Gamma\vdash}
\newcommand{\forallvars}[1]{\forall \overbar{#1}}
\newcommand{\olpolymorphic}[2]{\vdash^{ol} #1 \sqsubseteq #2}

\gram{\otte\ottinterrule}

\gram{\ottR\ottinterrule}

\gram{\ottt\ottinterrule}


\iffalse
\section{type check}

\subsection{Syntax}

Expressions and types have the same form. Compared to original type system which $\forall$ variables are of type $\star$, here are type annotatios in $\forall$ which can be other types. \\

\gram{\otte\ottinterrule}

Originally the definitions in the paper are\\

$\rho = \tau\ |\ \sigma \to \sigma$

$\tau = Int\ |\ \tau_1 \to \tau_2\ |\ a$
\\[2.0mm]

Here are some obversations:

1. $\rho$ have arrow type ranges over $\sigma$.

2. $\rho$ contains $\tau$.

3. There will be no $\forall$ in $\tau$. The understanding of this is because monotype $\tau$ is what can be omitted in the lambda annotations and will be inferred in the type inference algorithm.\\

To keep 1 and 2 true will be easy but it need to be careful to keep 3 true. Because the new type system will have more forms of types. For example an annotated expression $(\forall a. a \to a):\star$. It is not a $\sigma$ but it do contain $\sigma$. The solution is to select carefullly to keep $\tau$ away from $\forall$. \\

\gram{\ottR\ottinterrule}

\gram{ \ottt\ottinterrule}


%\subsection{Type-preserving substitution}


%A type-preserving substitution $\tpmapsto \sigma {e_1} {e_2}$ means substitute $e_2$ for $e_1$ where $e_1$ and $e_2$ are of same type $\sigma$.

%Sometimes $\sigma$ will be omitted if $e_1$ and $e_2$ are obviously of the same type.

\subsection{Operational Semantics: Call by name}

In type systems which have the same syntax for types and terms and support type-level computation, ensuring the decidability of type checking requires type-level computation to terminate, which is usually dependent on the strong normalization of the calculus. An unfortunate consequence of coupling decidability of type checking and strong normaliation is adding (unrestricted) general recursion to such calculi is difficult.

So here use an alternative to the conversion rule that make each type-level computation step explicit. Each beta reduction or expansion at the type level is introduced by type-safe cast construct. The $\castdowne$ operator allows a type conversion provided that the resulting type is a beta reduction of the original type of the term. For example, $e: (\lambda x:\star. x)\ Int$, because this beta reduction holds: $(\lambda x:\star. x)\ Int \longrightarrow Int$, so we have $(\castdowne e) : Int$. The $\castupe$ operator allows a type conversion provided that the reult type is a beta expansion of the original type of the term. We can have $(\castupe 3):(\lambda x:\star. x)\ Int$.

The rest of this section gives beta reduction on types. They will be used in \castupe and \castdowne.

\[
\inferrule*[right=S-Beta]
{  }
{ (\lambda x. e_1) e_2 \longrightarrow e_1 [x\mapsto e_2] }
\]

\[
\inferrule*[right=S-BetaAnn]
{  }
{ (\lambda x:\sigma. e_1) e_2 \longrightarrow e_1 [x\mapsto e_2] }
\]

\[
\inferrule*[right=S-App]
{ e_1 \longrightarrow e_1'  }
{ e_1 e_2 \longrightarrow e_1' e_2}
\]

\[
\inferrule*[right=S-CastDownUp]
{  }
{ \castdowne (\castupe e)  \longrightarrow e }
\]

\[
\inferrule*[right=S-CastDown]
{ e \longrightarrow e' }
{ \castdowne  e  \longrightarrow  \castdowne  e' }
\]

\[
\inferrule*[right=S-Ann]
{ e \longrightarrow e'  }
{ e:\sigma \longrightarrow e':\sigma}
\]

\[
\inferrule*[right=S-Let]
{  }
{ let\ x = e_1\ in\ e_2 \longrightarrow e_2[x\mapsto e_1] }
\]

\subsection{Specification of Typing}

\framebox{$ \judge e : \sigma$ }

$\star$ is the type of all types including itself.

\[
\inferrule*[right=Ax]
{} {\judge \star : \star}
\]

\[
\inferrule*[right=Var]
{x : \sigma \in \Gamma} {\judge x : \sigma}
\]

\[
\inferrule*[right=Lam]
{\Gamma,x: \tau \vdash e : \sigma } {\judge (\lambda x.\, e) : (\Pi x: \tau. \sigma)}
\]

Annotation must have type $\star$.

\[
\inferrule*[right=LamAnn]
{ \judge \sigma: \star \\
\Gamma,x: \sigma \vdash e : \sigma_2 } {\judge (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \sigma_2)}
\]

Because $x$ may appear in $e_1$ so there will be a substitution in $e_2$.

\[
\inferrule*[right=App]
{\judge e_1 : (\Pi x:\sigma_1. \sigma_2) \\ \judge e_2 : \sigma_1} {\judge e_1\,e_2 : \sigma_2\[\tpmapsto {\sigma_1} x {e_2}]}
\]

Annotation must have type $\star$.

\[
\inferrule*[right=Ann]
{\judge \sigma: \star\\
\judge e : \sigma }
{\judge (e :: \sigma) : \sigma }
\]

Typing rules for cast is the application of operational semantic.

\[
\inferrule*[right=CastUp]
{\judge e : \rho \\ \judge \sigma : \star \\ \rho \longrightarrow \sigma} {\judge (\mathsf{cast}^\uparrow\ e) : \sigma}
\]

\[
\inferrule*[right=CastDown]
{\judge e : \rho \\ \judge \sigma : \star \\ \rho \longrightarrow \sigma} {\judge (\mathsf{cast}_\downarrow\ e) : \sigma}
\]

Let will use substitution strategy because not only the type of $x$ but also what $x$ is will be important since it will be used in $e_2$. For example check expression $let\ x = Int\ in\ (\lambda n:x.n + 2)$. Another alternative is to put what let defines in the environment (namely $x=e_1$, which is $x=Int$ in the example), but here we just make the rule simpler.

\[
\inferrule*[right=Let]
{\judge e_1 : \sigma_1 \\ \Gamma \vdash e_2[\tpmapsto {\sigma_1} x {e_1}]: \sigma_2} {\judge ( let\ x = e_1\ in\ e_2 ) : \sigma_2 }
\]

Pi is of type $\star$.

\[
\inferrule*[right=ImplicitPi]
{\judge \overbar{\tau} : \star \\ \Gamma, \overbar{x:\tau} \vdash \rho : \star} {\judge (\forallvars{x : \tau}. \rho) : \star}
\]

\[
\inferrule*[right=ExplicitPi]
{\judge \sigma_1 : \star \\ \Gamma, x:\sigma_1 \vdash \sigma_2 : \star} {\judge (\Pi x:\sigma_1. \sigma_2) : \star}
\]

Because the variables in $\forall$ can have types other than $\star$, so we need to check the annotations and make sure it is valid.

\[
\inferrule*[right=Gen]
{\judge e : \rho \\
\alpha_i \notin ftv(\Gamma) \\
\tau_i : \star \\
\alpha_i : \tau_i \vdash \sigma : \star}
{\judge e : \forall(\alpha_i : \tau_i). \rho }
\]

\[
\inferrule*[right=Subs]
{\judge e : \sigma \\ \olpolymorphic{\sigma} {\sigma'}} {\judge e : \sigma' }
\]

\framebox{$ \olpolymorphic \sigma {\sigma'}$ }

Some rules motivated by the subtyping rule from \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.52.5145&rep=rep1&type=pdf}{Subtyping Dependent Types. D Aspinall, A Compagnoni. }

\[
\inferrule*[right=Skol]
{
\overbar{a} \notin ftv(\sigma)\\
\olpolymorphic \sigma \rho \\
}
{\olpolymorphic \sigma {\forallvars{a:\tau}.\rho}}
\]

Substitution must be type-preserving.

\[
\inferrule*[right=Spec]
{\overbar{b: \tau} \\
\olpolymorphic {\rho_1[\overbar{\tpmapsto \tau a b}]} {\rho_2}}
{\olpolymorphic {\forallvars{a:\tau}.\rho_1} {\rho_2}}
\]

\[
\inferrule*[right=Fun]
{\olpolymorphic  {\sigma_3} {\sigma_1} \\
\olpolymorphic  {\sigma_2} {\rho_4}}
{ \olpolymorphic {\Pi x:\sigma_1. \sigma_2} {\Pi x:\sigma_3. \rho_4}}
\]

Because beta reduction is explicit, so types are identical based only on alpha equivalence.

\[
\inferrule*[right=Alpha-Equal]
{  \alpha-equal(\sigma_1, \sigma_2)  }
{ \olpolymorphic {\sigma_1} {\sigma_2}}
\]

In application, first the arguments are required to be identical, for example $Vect\ 2$ and $Vect\ 3$ does not have any polymorphism relation. And second lambda need to be polymorphic.

\[
\inferrule*[right=App]
{
\olpolymorphic {\tau_1} {\tau_2}
}
{\olpolymorphic {\tau_1\, \sigma_1} {\tau_2\, \sigma_1} \\
}
\]

Polymorphism on Lam is just the relationship on its body.

\[
\inferrule*[right=Lam]
{
\olpolymorphic {\sigma_1} {\sigma_2}}
{\olpolymorphic {\lambda x. \sigma_1} {\lambda x. \sigma_2 }}
\]

In LamAnn the annotations are required to be identical. Because annotation can give a more specific type to the argument. If the body somewhere relys on the type of the argument, it will lead to difference.

\[
\inferrule*[right=Lamann]
{
\olpolymorphic {\sigma_2}{\sigma_4}}
{\olpolymorphic {\lambda x:\sigma_1. \sigma_2} {\lambda x:\sigma_1. \sigma_4}
}
\]

The annotations need to be identical. Also because the annotation may give a more specific type and may lead to some differences.

\[
\inferrule*[right=Ann]
{
\olpolymorphic {\sigma_1} {\sigma_3 }}
{\olpolymorphic {\sigma_1:\sigma_2} {\sigma_3:\sigma_2 }}
\]

In Cast, continue to compare the casted expressions.

\[
\inferrule*[right=Castup]
{
\olpolymorphic {\sigma_1} {\sigma_2}}
{\olpolymorphic {(\castupe \sigma_1)} {(\castupe \sigma_2) }}
\]

\[
\inferrule*[right=Castdown]
{
 \olpolymorphic {\sigma_1} {\sigma_2}}
 { \olpolymorphic {(\castdowne \sigma_1)} {(\castdowne \sigma_2)}}
\]

In Let, $e_1$ need to be identical and than compare the body. Let should have similar rule as App.

\[
\inferrule*[right=Let]
{
\olpolymorphic {\sigma_1} {\sigma_2 }}
{\olpolymorphic {(let\ x = e_1\ in\ \sigma_1)} {(let\ x = e_1\ in\ \sigma_2) }}
\]


\clearpage

\fi

\subsection{algorithmic Typing}

\newcommand{\checktype}{\Gamma\vdash_\Downarrow}
\newcommand{\infertype}{\Gamma\vdash_\Uparrow}
\newcommand{\infercheck}{\Gamma\vdash_\delta}

\newcommand{\checktypeno}{\vdash_\Downarrow}
\newcommand{\infertypeno}{\vdash_\Uparrow}
\newcommand{\infercheckno}{\vdash_\delta}

\newcommand{\instinfer}{\vdash^{inst}_\Uparrow}
\newcommand{\instcheck}{\vdash^{inst}_\Downarrow}
\newcommand{\instinfercheck}{\vdash^{inst}_\delta}

\newcommand{\polyinfer}{\Gamma\vdash^{poly}_\Uparrow}
\newcommand{\polycheck}{\Gamma\vdash^{poly}_\Downarrow}
\newcommand{\polycheckno}{\vdash^{poly}_\Downarrow}
\newcommand{\polyinfercheck}{\vdash^{poly}_\delta}

\newcommand{\dsk}{\vdash^{dsk}}

\newcommand{\unify}{\vdash^{unify}}


$\Gamma, \Theta, \Delta  = \cdot~|~\Gamma, x~|~\Gamma, x:\sigma~|~\Gamma, \widehat{\alpha}~|~\Gamma, \widehat{\alpha}=\sigma~|~\Gamma, \widehat{\alpha}:\sigma~|~\Gamma, \widehat{\alpha}:\sigma = \sigma_2~|~\Gamma, \blacktriangleright_{\widehat \alpha}$

\framebox{$ \infercheck e : \rho \dashv \Theta $ } infer $\Uparrow$ check $\Downarrow$ $\delta = \Uparrow \mid \Downarrow$

\[
\inferrule*[right=AX]
{\Gamma \instinfercheck \star \sqsubseteq \rho \dashv \Theta}
{\infercheck \star : \rho \dashv \Theta}
\]

\[
\inferrule*[right=Var]
{x:\sigma \in \Gamma \\ \Gamma \instinfercheck \sigma \sqsubseteq \rho \dashv \Theta }
{\infercheck x : \rho \dashv \Theta}
\]

\[
\inferrule*[right=Lam-Infer]
{\Gamma, \widehat{\alpha}:\star, \widehat{\beta}:\star, x: \widehat \alpha \checktypeno e : \widehat \beta \dashv \Theta, x:\widehat \alpha , \Delta}
{\infertype (\lambda x.\, e) : (\Pi x: \widehat \alpha. \widehat \beta) \dashv \Theta}
\]

\[
\inferrule*[right=Lam-Check]
{\Gamma,x: \sigma_1 \polycheckno e : \sigma_2 \dashv \Theta, x: \sigma_1, \Delta}
{\checktype (\lambda x.\, e) : (\Pi x: \sigma_1. \sigma_2) \dashv \Theta}
\]

\[
\inferrule*[right=LamAnn-Infer]
{
\checktype \sigma:\star \dashv \Theta_1 \\
\Theta_1, x: \sigma \infertypeno e : \rho \dashv \Theta, x:\sigma, \Delta }
{\infertype (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \rho)\dashv \Theta}
\]

\[
\inferrule*[right=LamAnn-Check]
{
\checktype \sigma:\star \dashv \Theta_1 \\
\Theta_1 \instcheck \sigma_1 \sqsubseteq \sigma \dashv \Theta_2 \\
\Theta_2,x: \sigma \polycheckno e : \sigma_2 \dashv \Theta, x:\sigma, \Delta }
{\checktype (\lambda x:\sigma.\, e) : (\Pi x: \sigma_1. \sigma_2) \dashv \Theta}
\]

\[
\inferrule*[right=App]
{\infertype e_1 : (\Pi x:\sigma_1. \sigma_2) \dashv \Theta_1 \\
\Theta_1 \polycheckno e_2 : \sigma_1 \dashv \Theta_2 \\
\Theta_2 \instinfercheck \sigma_2 [\tpmapsto {\sigma_1} x {e_2}] \sqsubseteq \rho \dashv \Theta}
{\infercheck e_1\,e_2 : \rho \dashv \Theta}
\]

\[
\inferrule*[right=App2]
{\infertype e_1 : \widehat \alpha \dashv \Theta_1[\widehat \alpha] \\
\Theta_1[\widehat \alpha_1, \widehat \alpha_2, \widehat \alpha = \Pi x:\widehat \alpha_1. \widehat \alpha_2] \polycheckno e_2 : \widehat \alpha_1 \dashv \Theta_2 \\
\Theta_2 \instinfercheck \widehat \alpha_2 [\tpmapsto {\sigma_1} x {e_2}] \sqsubseteq \rho \dashv \Theta}
{\infercheck e_1\,e_2 : \rho \dashv \Theta}
\]

\[
\inferrule*[right=App3]
{\infertype e_1 : \widehat \alpha \dashv \Theta_1[\widehat \alpha:\tau_\alpha] \\
\Theta_1[\widehat \alpha:\tau_\alpha] \instcheck \tau_\alpha \sqsubseteq \star \dashv \Theta_2[\widehat \alpha:\tau_\alpha] \\
\Theta_2[\widehat \alpha_1, \widehat \alpha_2, \widehat \alpha = \Pi x:\widehat \alpha_1. \widehat \alpha_2] \polycheckno e_2 : \widehat \alpha_1 \dashv \Theta_3 \\
\Theta_3 \instinfercheck \widehat \alpha_2 [\tpmapsto {\sigma_1} x {e_2}] \sqsubseteq \rho \dashv \Theta}
{\infercheck e_1\,e_2 : \rho \dashv \Theta}
\]

\[
\inferrule*[right=Ann]
{
\checktype \sigma : \star \dashv \Theta_1\\
\Theta_1 \polycheckno (e:\sigma) \dashv \Theta_2\\
\Theta_2 \instinfercheck \sigma : \rho \dashv \Theta}
{\infercheck (e : \sigma) : \rho \dashv \Theta}
\]

\[
\inferrule*[right=CastUp-Check]
{[\Gamma]\rho \longrightarrow \sigma \\
\polycheck e : \sigma \dashv \Theta}
{\checktype (\castupe e) : \rho \dashv \Theta}
\]

\[
\inferrule*[right=CastDown]
{\infertype e : \rho_1 \dashv \Theta_1 \\
[\Theta_1]\rho_1 \longrightarrow \sigma \\
\Theta_1 \instinfercheck \sigma \sqsubseteq \rho_2 \dashv \Theta}
{\infercheck (\castdowne e) : \rho_2 \dashv \Theta}
\]

\[
\inferrule*[right=Let]
{\Gamma \infertypeno e_1 : \sigma \dashv \Theta_1 \\
\infercheck e_2[\tpmapsto {\sigma} x {e_1}]: \rho \dashv \Theta}
{\infercheck ( let\ x = e_1\ in\ e_2 ) : \rho \dashv \Theta}
\]

\[
\inferrule*[right=ImplicitPi]
{\checktype \tau : \star \dashv \Theta_1 \\
\Theta_1, x:\tau \checktypeno \rho_1 : \star \dashv \Theta_2 \\
\Theta_2 \instinfercheck \star \sqsubseteq \rho
}
{\infercheck (\forall x : \tau. \rho_1) : \rho \dashv \Theta}
\]

\[
\inferrule*[right=ExplicitPi]
{\checktype \sigma_1 : \star \dashv \Theta_1 \\
\Theta_1, x:\sigma_1 \checktypeno \sigma_2 : \star \dashv \Theta_2 \\
\Theta_2 \instinfercheck \star \sqsubseteq \rho
}
{\infercheck (\Pi x : \sigma_1. \sigma_2) : \rho \dashv \Theta}
\]

\framebox{$ \Gamma \polyinfercheck e : \sigma \dashv \Theta$ }

\[
\inferrule*[right=Gen-Infer]
{\infertype e :\rho_1 \dashv \Theta\\
\rho = [\Theta]\rho_1 \\
\overbar{\widehat \alpha:\tau}=\Gamma \cap (ftv(\rho)-ftv(\Gamma))
}
{\polyinfer e :(\forallvars{x:\tau}. \rho[\overbar{\widehat \alpha} \mapsto \overbar{x}]) \dashv \Theta}
\]

\[
\inferrule*[right=Gen-Check]
{
[\Gamma]\sigma = \forallvars{\alpha:\tau}. \rho \\
\Gamma, \overbar{\alpha:\tau} \checktypeno e :\rho \dashv \Theta
}
{\polycheck e : \sigma \dashv \Theta}
\]

\framebox{$ \Gamma \instinfercheck \sigma \sqsubseteq \rho \dashv \Theta$ }

\[
\inferrule*[right=Inst-Infer]
{[\Gamma] \sigma = \forallvars{x:\tau}. \rho
}
{\Gamma \instinfer \sigma \sqsubseteq \rho[\overbar{\tpmapsto {\tau} x {\widehat{\alpha}}}] \dashv \Gamma, \overbar{\widehat{\alpha}:\tau}}
\]

\[
\inferrule*[right=Inst-Check]
{\Gamma \dsk [\Gamma]\sigma \sqsubseteq [\Gamma]\rho \dashv \Theta} { \Gamma \instcheck \sigma \sqsubseteq \rho \dashv \Theta}
\]

\newcommand{\dskunify}[0]{\vdash^{\chi}}
\framebox{$ \Gamma \dskunify \sigma_1 \sqsubseteq \sigma_2 \dashv \Theta$} $\chi = dsk~|~unify$

\[
\inferrule*[right=ImplicitPi-dsk-L]
{
\Gamma, \overbar{x:\tau} \dsk \sigma_1 \sqsubseteq \rho \dashv \Theta, \overbar{x:\tau}, \Delta}
{\Gamma \dsk \sigma_1 \sqsubseteq \forallvars{x:\tau}. \rho \dashv \Theta}
\]

\[
\inferrule*[right=ImplicitPi-dsk-R]
{\Gamma , \blacktriangleright_{\widehat \alpha}, \overbar{\widehat \alpha : \tau} \dsk \rho_1[\overbar{\tpmapsto \tau x {\widehat \alpha}}] \sqsubseteq \rho_2 \dashv \Theta, \blacktriangleright_{\widehat \alpha}, \Delta}
{\Gamma \dsk \forallvars{x:\tau}.\rho_1 \sqsubseteq \rho_2 \dashv \Theta}
\]

\[
\inferrule*[right=ImplicitPi-unify]
{\Gamma \unify  \sigma_1 \sqsubseteq \sigma_3 \dashv \Theta_1 \\
\Theta_1, x:\sigma_1 \unify [\Theta_1]\sigma_2 \sqsubseteq [\Theta_1]\sigma_4 \dashv \Theta, x:\sigma_1, \Delta}
{ \Gamma \unify \forall x:\sigma_1. \sigma_2 \sqsubseteq \forall x:\sigma_3. \sigma_4 \dashv \Theta}
\]

\[
\inferrule*[right=ExplicitPi]
{\Gamma \dskunify  \sigma_3 \sqsubseteq \sigma_1 \dashv \Theta_1 \\
\Theta_1, x:\sigma_1 \dskunify [\Theta_1]\sigma_2 \sqsubseteq [\Theta_1]\sigma_4 \dashv \Theta, x:\sigma_1, \Delta}
{ \Gamma \dskunify \Pi x:\sigma_1. \sigma_2 \sqsubseteq \Pi x:\sigma_3. \sigma_4 \dashv \Theta}
\]

\[
\inferrule*[right=App]
{
\Gamma \unify \sigma_1 \sqsubseteq \sigma_2 \dashv \Theta_1 \\
\Theta_1 \dskunify [\Theta_1]\tau_1 \sqsubseteq [\Theta_1]\tau_2 \dashv \Theta
}
{\Gamma \dskunify \tau_1\, \sigma_1 \sqsubseteq \tau_2\, \sigma_2 \dashv \Theta}
\]

\[
\inferrule*[right=Lam]
{
\Gamma, x \dskunify \sigma_1 \sqsubseteq \sigma_2 \dashv \Theta, x, \Delta}
{\Gamma \dskunify \lambda x. \sigma_1 \sqsubseteq \lambda x. \sigma_2 \dashv \Theta }
\]


\[
\inferrule*[right=Lamann]
{
\Gamma \unify \sigma_1 \sqsubseteq \sigma_3 \dashv \Theta_1 \\
\Theta_1, x:\sigma_1 \dskunify [\Theta_1]\sigma_2 \sqsubseteq [\Theta_1]\sigma_4 \dashv \Theta, x:\sigma_1, \Delta }
{\Gamma \dskunify \lambda x:\sigma_1. \sigma_2 \sqsubseteq \lambda x:\sigma_3. \sigma_4 \dashv \Theta
}
\]

\[
\inferrule*[right=Ann]
{
\Gamma \unify \sigma_2 \sqsubseteq \sigma_4 \dashv \Theta_1 \\
\Theta_1 \dskunify  [\Theta_1]\sigma_1 \sqsubseteq [\Theta_1]\sigma_3 \dashv \Theta }
{\Gamma \dskunify \sigma_1:\sigma_2 \sqsubseteq \sigma_3:\sigma_4 \dashv \Theta}
\]

\[
\inferrule*[right=Castup]
{
\Gamma \dskunify  \sigma_1 \sqsubseteq \sigma_2 \dashv \Theta}
{\Gamma \dskunify (\castupe \sigma_1) \sqsubseteq  (\castupe \sigma_2) \dashv \Theta}
\]

\[
\inferrule*[right=Castdown]
{
\Gamma \dskunify  \sigma_1 \sqsubseteq \sigma_2 \dashv \Theta}
{\Gamma \dskunify  (\castdowne \sigma_1) \sqsubseteq  (\castdowne \sigma_2) \dashv \Theta}
\]

\[
\inferrule*[right=Let]
{
\Gamma \unify \sigma_1 \sqsubseteq \sigma_3 \dashv \Theta_1 \\
\Theta_1 \dskunify  [\Theta_1]\sigma_2 \sqsubseteq [\Theta_1]\sigma_4 \dashv \Theta }
{\Gamma \dskunify  (let\ x = \sigma_1\ in\ \sigma_2) \sqsubseteq  (let\ x = \sigma_3\ in\ \sigma_4) }
\]

\[
\inferrule*[right=Var]
{ }
{\Gamma[x\{:\sigma\}] \dskunify x \sqsubseteq x \dashv \Gamma[x\{:\sigma\}] }
\]

\[
\inferrule*[right=EVar]
{ }
{\Gamma[\widehat \alpha\{:\tau_\alpha\} ] \dskunify \widehat \alpha \sqsubseteq \widehat \alpha \dashv \Gamma[\widehat \alpha\{:\tau_\alpha\}] }
\]


\framebox{$\Gamma[\alpha] \dskunify \widehat \alpha \sqsubseteq \rho \dashv \Theta, \alpha \notin ftv(\rho)$}

\[
\inferrule*[right=EVar-Tau-Uni]
{ }
{\Gamma[\widehat \alpha ] \unify \widehat \alpha \sqsubseteq \tau \dashv \Gamma[\widehat \alpha=\tau]}
\]

\[
\inferrule*[right=EVar-EVar]
{ }
{\Gamma[\widehat \alpha][\widehat \beta\{:\tau_\beta\}] \dskunify \widehat \alpha \sqsubseteq \widehat \beta \dashv
\Gamma[\widehat \alpha][\widehat \beta\{:\tau_\beta\} = \widehat \alpha] }
\]

\[
\inferrule*[right=EVar-Fun]
{\Gamma[\widehat \alpha_1, \widehat \alpha_2, \widehat \alpha = \Pi x: \widehat \alpha_1. \widehat \alpha_2]
    \dsk  \sigma \sqsubseteq \widehat \alpha_1 \dashv \Theta_1 \\
\Theta_1, x: \sigma \dsk \alpha_2 \sqsubseteq [\Theta_1] \rho \dashv \Theta, x:\sigma, \Delta}
{\Gamma[\widehat \alpha] \dsk \widehat \alpha \sqsubseteq (\Pi x:\sigma. \rho) \dashv \Theta}
\]

\[
\inferrule*[right=EVar-App]
{
\Gamma[\widehat \alpha_1, \widehat \alpha_2, \widehat \alpha = \widehat \alpha_1~\widehat \alpha_2]
    \unify \alpha_2 \sqsubseteq \sigma_1 \dashv \Theta_1 \\
\Theta_1 \dsk \alpha_1 \sqsubseteq [\Theta_1]\tau_1 \dashv \Theta
}
{\Gamma[\widehat \alpha]\dsk \widehat \alpha \sqsubseteq (\tau_1\, \sigma_1) \dashv \Theta}
\]

\[
\inferrule*[right=EVar-Lam]
{
\Gamma[\widehat \alpha_1, \widehat \alpha = \lambda x. \alpha_1], x \dsk \alpha_1 \sqsubseteq \sigma_2 \dashv \Theta, x, \Delta}
{\Gamma[\widehat \alpha] \dsk \widehat \alpha \sqsubseteq (\lambda x. \sigma_2) \dashv \Theta }
\]


\[
\inferrule*[right=EVar-Lamann]
{
\Gamma[\widehat \alpha_1, \widehat \alpha_2, \widehat \alpha = \lambda x:\widehat \alpha_1. \widehat \alpha_2]
\unify \widehat \alpha_1 \sqsubseteq \sigma_1 \dashv \Theta_1 \\
\Theta_1, x:\sigma_1 \dsk \widehat \alpha_2 \sqsubseteq [\Theta_1]\sigma_2 \dashv \Theta, x:\sigma_1, \Delta }
{\Gamma[\widehat \alpha]\dsk \widehat \alpha \sqsubseteq (\lambda x:\sigma_1. \sigma_2) \dashv \Theta
}
\]

\[
\inferrule*[right=EVar-Ann]
{
\Gamma[\widehat \alpha_1, \widehat \alpha_2, \widehat \alpha_1 = \widehat \alpha_1:\widehat \alpha_2]
\unify \widehat \alpha_2 \sqsubseteq \sigma_2 \dashv \Theta_1 \\
\Theta_1 \dsk \widehat \alpha_1 \sqsubseteq [\Theta_1]\sigma_1 \dashv \Theta }
{\Gamma[\widehat \alpha] \dsk \widehat \alpha \sqsubseteq (\sigma_1:\sigma_2) \dashv \Theta}
\]

\[
\inferrule*[right=EVar-Castup]
{
\Gamma[\widehat \alpha_1, \alpha = \castupe \alpha_1] \dsk  \alpha_1 \sqsubseteq \sigma_1 \dashv \Theta}
{\Gamma[\widehat \alpha] \dsk  \widehat \alpha \sqsubseteq  (\castupe \sigma_1) \dashv \Theta}
\]

\[
\inferrule*[right=EVar-Castdown]
{
\Gamma[\widehat \alpha_1, \alpha = \castdowne \alpha_1] \dsk  \alpha_1 \sqsubseteq \sigma_1 \dashv \Theta}
{\Gamma[\widehat \alpha] \dsk  \widehat \alpha \sqsubseteq  (\castdowne \sigma_2) \dashv \Theta}
\]

\[
\inferrule*[right=EVar-Let]
{
\Gamma[\widehat \alpha_1, \widehat \alpha_2, \widehat \alpha = let~x=\widehat \alpha_1~in~\widehat \alpha_2]
\unify \widehat \alpha_1 \sqsubseteq \sigma_1 \dashv \Theta_1 \\
\Theta_1 \dsk \widehat \alpha_2 \sqsubseteq [\Theta_1]\sigma_2 \dashv \Theta }
{\Gamma[\widehat \alpha] \dsk \widehat \alpha  \sqsubseteq  (let\ x = \sigma_1\ in\ \sigma_2) \dashv \Theta }
\]

\framebox{$\Gamma[\alpha:\tau_\alpha] \dskunify \widehat \alpha \sqsubseteq \rho \dashv \Theta, \alpha \notin ftv(\rho)$}

\[
\inferrule*[right=EVar-Typed]
{
\sigma_\rho = [\Gamma [\widehat \alpha:\tau_\alpha] ] get\_type(\rho)\\
\Gamma[\widehat \alpha:\tau_\alpha] \dsk \sigma_\rho \sqsubseteq \tau_\alpha \dashv \Theta_1[\widehat \alpha:\tau_\alpha\{=\tau_1\}] \\
\Theta_2 = \Theta_1[\widehat \alpha\{=\tau_1\}] \\
\Theta_2 \dskunify [\Theta_2]\widehat \alpha \sqsubseteq [\Theta_2]\rho \dashv \Theta
}
{\Gamma[\widehat \alpha:\tau_\alpha] \dskunify \widehat \alpha \sqsubseteq \rho \dashv \Theta }
\]

\clearpage


\iffalse
\subsection{Translation}

\newcommand{\transto}[1]{\leadsto#1}
\newcommand{\translated}[1]{|#1|}
\newcommand{\cyancolorbox}[1]{\colorbox{cyan!30}{$#1$}}
%\newcommand{\invariant}[2]{\leadsto #1 :#2}
\newcommand{\invariant}[2]{}

\subsubsection{Target Language}

\gram{\ottE\ottinterrule}

\subsubsection{Translation Rules}

\framebox{$ \infercheck e : \rho \invariant{E}{|\rho|}$ } infer $\Uparrow$ check $\Downarrow$ $\delta = \Uparrow \mid \Downarrow$

\[
\inferrule*[right=AX]
{} {\infercheck \star : \star \transto{\star}}
\]

\[
\inferrule*[right=Var]
{x:\sigma \in \Gamma \\ \instinfercheck \sigma \sqsubseteq \rho \transto{f} } {\infercheck x : \rho \transto{f\ x}}
\]

\[
\inferrule*[right=Lam-Infer]
{\Gamma,x: \tau \infertypeno e : \rho \transto{E} }
{\infertype (\lambda x.\, e) : (\Pi x: \tau. \rho) \transto {\lambda(x:\translated{\tau}). E}}
\]

\[
\inferrule*[right=Lam-Check]
{\Gamma,x: \sigma_1 \polycheckno e : \sigma_2 \transto{E}
} {\checktype (\lambda x.\, e) : (\Pi x: \sigma_1. \sigma_2) \transto{\lambda(x:\translated{\sigma_1}).E}}
\]

\[
\inferrule*[right=LamAnn-Infer]
{
\checktype \sigma:\star \\
\Gamma,x: \sigma \infertypeno e : \rho \transto{E}
} {\infertype (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \rho) \transto{\lambda(x:\translated{\sigma}). E}}
\]

\[
\inferrule*[right=LamAnn-Check]
{
\checktype \sigma:\star \\
\translated{\sigma_1}, \translated{\sigma} \dsk \sigma_1 \sqsubseteq \sigma \transto{f} \\
\Gamma,x: \sigma \polycheckno e : \sigma_2 \transto{E} \\
}
{\checktype (\lambda x:\sigma.\, e) : (\Pi x: \sigma_1. \sigma_2) \transto{ \lambda(x:\translated{\sigma_1}). E[\tpmapsto \sigma x {f\ x}] }}
\]

\[
\inferrule*[right=App]
{\infertype e_1 : (\Pi x:\sigma_1. \sigma_2) \transto {E_1} \\
\polycheck e_2 : \sigma_1 \transto{E_2}\\
\instinfercheck \sigma_2 [\tpmapsto {\sigma_1} x e_2] \sqsubseteq \rho \transto{f}}
{\infercheck e_1\,e_2 : \rho \transto{f\ (E_1\ E_2)}}
\]

\[
\inferrule*[right=ExplicitPi]
{\checktype \tau_1 : \star \\ \Gamma, x:\tau_1 \checktypeno \tau_2 : \star }
{\infercheck (\Pi x:\tau_1. \tau_2) : \star \transto{(\Pi x:\translated{\tau_1}. \translated{\tau_2})}}
\]

\[
\inferrule*[right=Ann]
{
\checktype \sigma : \star \\
\polycheck (e:\sigma) \transto{E}\\
\instinfercheck \sigma : \rho \transto{f}}
{\infercheck (e : \sigma) : \rho \transto{f\ E}}
\]

\[
\inferrule*[right=CastUp-Check]
{ \rho \longrightarrow \sigma \\ \polycheck e : \sigma \transto{E} }
{\checktype (\castupe e) : \rho \transto{\castupe [\translated{\rho}]\ E}}
\]

\[
\inferrule*[right=CastDown]
{\infertype e : \rho_1 \transto{E}\\
\rho_1 \longrightarrow \sigma \\
\instinfercheck \sigma \sqsubseteq \rho_2\transto {f}}
{\infercheck (\castdowne e) : \rho_2 \transto {f\ (\castdowne E)}}
\]

\[
\inferrule*[right=Let]
{\polyinfer e_1 : \sigma \transto{E_1}\\
\infercheck e_2[\tpmapsto \sigma x {e_1}]: \rho \transto{E_2}
}
{\infercheck ( let\ x = e_1\ in\ e_2 ) : \rho \transto{(\lambda x:\translated \sigma. E_2)\ E_1}}
\]

\framebox{$ \infercheck \sigma : \star \invariant{E}{*}$ }

\[
\inferrule*[right=ImplicitPi]
{\checktype \tau : \star \\ \Gamma, x:\tau \checktypeno \rho : \star}
{\infercheck (\forall x : \tau. \rho) : \star \transto {\Pi (x:\translated \tau). \translated \rho}}
\]

\framebox{$ \infercheck \rho : \star \invariant{E}{*}$ }

\[
\inferrule*[right=FunPoly]
{\checktype \sigma_1 : \star \\
\Gamma, x:\sigma_1 \checktypeno \sigma_2 : \star }
{\infercheck (\Pi x : \sigma_1. \sigma_2) : \star \transto{\Pi (x:\translated {\sigma_1}). \translated {\sigma_2}}}
\]

\framebox{$ \Gamma \polyinfercheck e : \sigma \invariant{E}{|\sigma|}$ }

\[
\inferrule*[right=Gen-Infer]
{\infertype e :\rho \transto{E} \\ \overbar{x:\tau}=ftv(\rho)-ftv(\Gamma) \\
\checktype (\forallvars{x:\tau}. \rho):\star } {\polyinfer e :(\forallvars{x:\tau}. \rho) \transto{\lambda (\overbar{x:\translated \tau}). E}}
\]

\[
\inferrule*[right=Gen-Check]
{
pr(\sigma) = \forallvars{x:\tau}. \rho \transto{f} \\
\overbar{x:\tau} \notin ftv(\Gamma) \\
\checktype e :\rho \transto{E}
} {\polycheck e : \sigma \transto{f\ (\lambda (\overbar{x:\translated \tau}). E)}}
\]

\framebox{$ \instinfercheck \sigma \sqsubseteq \rho \invariant{f}{|\sigma|\to|\rho|}$ }

\[
\inferrule*[right=Inst-Infer]
{\overbar{y : \tau}
}
{\instinfer \forallvars{x:\tau} . \rho \sqsubseteq \rho[\overbar{\tpmapsto \tau x y}] \transto
{\lambda (a: \translated{\forallvars{x:\tau} . \rho} ). (a\ \translated{\overbar{\tau_{\beta}}})}}
\]

\[
\inferrule*[right=Inst-Check]
{\translated{\sigma}, \translated{\rho}\dsk \sigma \sqsubseteq \rho \transto {f} \\
}
{\instcheck \sigma \sqsubseteq \rho \transto {f}}
\]

\framebox{$pr(\sigma)=\forallvars{x:\tau}.\rho \invariant{f}{|\forallvars{x:\tau}.\rho|\to|\sigma|}$}

\[
\inferrule*[right=Pr-poly]
{pr(\rho_1) = \forallvars{b:\tau_2}. \rho_2 \transto{f}\\ \overbar{a} \cap \overbar{b} = \emptyset
}
{pr(\forallvars{a:\tau_1}. \rho_1) = \forallvars{a:\tau_1. b:\tau_2}. \rho_2 \\
\transto{\lambda (x: \translated{\forallvars{a:\tau_1. b:\tau_2}. \rho_2  }).\lambda (\overbar{a:\translated{{\tau_1}}}). f\ (x\ \overbar{a})}}
\]

\[
\inferrule*[right=Pr-fun]
{pr(\sigma_2) = \forallvars{a:\tau}. \rho_2 \transto{f} \\ \overbar{a} \cap ftv(\sigma_1) = \emptyset
}
{pr(\Pi x:\sigma_1. \sigma_2) = \forallvars{a:\tau}. \Pi x:\sigma_1. \rho_2 \\
\transto{\lambda (x:\translated{ \forallvars{a:\tau}. \Pi x:\sigma_1. \rho_2 }). \lambda (y:\translated{\sigma_1}). f\ (\lambda (\overbar{a:\translated{\tau}}). x\ a\ y) }}
\]

\[
\inferrule*[right=Pr-other-case]
{  } {pr(\tau)=\tau \transto {\lambda (x:\translated{\tau}). x}}
\]

\framebox{$\sigma \dsk \sigma_1 \sqsubseteq \sigma_2 \invariant{f}{|\sigma_1|\to|\sigma_2|}$}

\newcommand{\sigmal}{\sigma_{l}}
\newcommand{\sigmar}{\sigma_{r}}

\[
\inferrule*[right=Deep-skol]
{pr(\sigma_2)=\forallvars{a:\tau}. \rho \transto{f_1}\\ a \notin ftv(\sigma_1) \\
\sigmar = \Pi a:\translated{\tau}. \rho_r \\
\sigmal, \rho_r \dsk \sigma_1 \sqsubseteq \rho \transto{f_2}
}
{ \sigmal, \sigmar\dsk \sigma_1 \sqsubseteq \sigma_2 \transto{\lambda x:\sigma_l. f_1\ (\lambda(\overbar{a:\translated{\tau}}). f_2\ x) }}
\]

\framebox{$\sigma \dsk \sigma \sqsubseteq \rho \invariant{f}{|\sigma| \to|\rho|}$}

\[
\inferrule*[right=Alpha-Equal]
{  \alpha-equal(\sigma \sigma)  }
{  \sigmal, \sigmar \dsk \sigma \sqsubseteq \rho \transto{\lambda x: \sigmal. x}}
\]

\[
\inferrule*[right=Spec]
{\overbar{b: \tau} \\
\translated{\rho_1[\overbar{\tpmapsto \tau a b}]}, \translated{\rho_2} \dsk \rho_1[\overbar{\tpmapsto \tau a b}] \sqsubseteq \rho_2 \transto{f} \\
}
{\sigmal, \sigmar \dsk \forallvars{a:\tau}.\rho_1 \sqsubseteq \rho_2 \\
\transto {\lambda x:\sigmal. f\ (x\ \translated{\overbar{b}}) }}
\]

\[
\inferrule*[right=Fun]
{\translated{\sigma_3}, \translated{\sigma_1}\dsk  \sigma_3 \sqsubseteq \sigma_1 \transto{f_1} \\
\translated{\sigma_2[x \mapsto g_1\ y]}, \translated{\rho_4}\dsk  \sigma_2[x \mapsto g_1\ y] \sqsubseteq \rho_4 \transto{f_2} \\
 }
{\sigmal, \sigmar \dsk \Pi x:\sigma_1. \sigma_2 \sqsubseteq \Pi x:\sigma_3. \rho_4 \\
\transto {\lambda x:\sigmal. \lambda y:\translated{\sigma_3} . f_2\ (x\ (f_1\ y))}
}
\]

\[
\inferrule*[right=App]
{\sigmal \longrightarrow \sigmal' \\
\sigmar \longrightarrow \sigmar' \\
\sigmal', \sigmar' \dsk \tau_1 \sqsubseteq \tau_2 \transto {f}\\
}
{\sigmal, \sigmar \dsk \tau_1\, \sigma_1 \sqsubseteq \tau_2\, \sigma_1 \\
\transto {\lambda x:\sigmal. \castupe [\sigmar] (f\ (\castdowne x))}}
\]

\[
\inferrule*[right=Lam]
{
\sigmal, \sigmar \dsk \sigma_1 \sqsubseteq \sigma_2 \transto {f}}
{ \sigmal, \sigmar \dsk \lambda x. \sigma_1 \sqsubseteq \lambda x. \sigma_2 \transto {f}}
\]


\[
\inferrule*[right=Lamann]
{
\sigmal, \sigmar \dsk \sigma_2 \sqsubseteq \sigma_4 \transto{f}}
{\sigmal, \sigmar \dsk \lambda x:\sigma_1. \sigma_2 \sqsubseteq \lambda x:\sigma_1. \sigma_4 \\
\transto {f}}
\]


\[
\inferrule*[right=Ann]
{
\sigmal, \sigmar \dsk  \sigma_1 \sqsubseteq \sigma_3 \transto{f}}
{\sigmal, \sigmar \dsk \sigma_1:\sigma_2 \sqsubseteq \sigma_3:\sigma_2 \transto {f}}
\]

\[
\inferrule*[right=Castup]
{
\sigmal, \sigmar \dsk  \sigma_1 \sqsubseteq \sigma_2 \transto {f}}
{\sigmal, \sigmar \dsk  (\castupe \sigma_1) \sqsubseteq  (\castupe \sigma_2) \transto {f}}
\]


\[
\inferrule*[right=Castdown]
{\sigmal \longrightarrow \sigmal' \\
\sigmar \longrightarrow \sigmar' \\
\sigmal', \sigmar' \dsk  \sigma_1 \sqsubseteq \sigma_2 \transto {f}
}
{\sigmal, \sigmar \dsk  (\castdowne \sigma_1) \sqsubseteq  (\castdowne \sigma_2)
\transto{ \lambda x:\sigmal. \castupe [\sigmar] (f\ (\castdowne x))}}
\]

\[
\inferrule*[right=Let]
{\sigmal \longrightarrow \sigmal'\\
\sigmar \longrightarrow \sigmar' \\
\sigmal', \sigmar' \dsk  \sigma_1 \sqsubseteq \sigma_2 \transto {f}
}
{\sigmal, \sigmar \dsk  (let\ x = e_1\ in\ \sigma_1) \sqsubseteq  (let\ x = e_1\ in\ \sigma_2) \\
\transto{ \lambda x:\sigmal. \castupe [\sigmar] (f\ (\castdowne x))}}
\]

\clearpage

%\begin{landscape}

\begin{figure*}

\[
\inferrule* [right=CastDown]
    {
        \inferrule* [right=CastUp]
        {
            \inferrule* [right=Deep-Skol]
            { %pr(\forall a. a \to a) = \forall a. a \to a \\
                \inferrule* [right=Spec]
                {
                    \inferrule*[right=alpha-equal]
                    {  }
                    {(\Pi a:\star. a \to a), (a \to a)  \dsk (a \to a) \sqsubseteq (a \to a) \\
                     \transto{\lambda x:(a \to a). x}
                    }
                }
                {(\Pi a:\star. \Pi b:\star. a \to b), ( a \to a)
                 \dsk (\forall a. \forall b. a \to b) \sqsubseteq (a \to a) \\
                 \transto{\lambda x:(\Pi a:\star. \Pi b:\star. a \to b).
                    (\lambda x:(a \to a). x)\ (x\ a\ a) }
                }
            }
            {(\Pi a:\star. \Pi b:\star. a \to b), (\Pi a:\star. a \to a)
             \dsk (\forall a. \forall b. a \to b) \sqsubseteq (\forall a. a \to a) \\
             \transto{\lambda x:(\Pi a:\star. \Pi b:\star. a \to b). f_1 (\lambda a:\star.
                 (\lambda x:(\Pi a:\star. \Pi b:\star. a \to b).  (\lambda x:(a \to a). x)\ (x\ a\ a) ) \ x) }
            }
        }
        {(\Pi a:\star. \Pi b:\star. a \to b), (\Pi a:\star. a \to a)
          \dsk \castupe (\forall a. \forall b. a \to b) \sqsubseteq \castupe (\forall a. a \to a) \\
         \transto{\lambda x:(\Pi a:\star. \Pi b:\star. a \to b). f_1 (\lambda a:\star.
                 (\lambda x:(\Pi a:\star. \Pi b:\star. a \to b).  (\lambda x:(a \to a). x)\ (x\ a\ a) ) \ x) }
        }
    }
    {\castdowne \castupe (\Pi a:\star. \Pi b:\star. a \to b), \castdowne \castupe (\Pi a:\star. a \to a) \dsk \castdowne \castupe (\forall a. \forall b. a \to b) \sqsubseteq \castdowne \castupe (\forall a. a \to a) \\
        \transto{ \lambda x: \castdowne \castupe (\Pi a:\star. \Pi b:\star. a \to b). \castupe [\castdowne \castupe (\Pi a:\star. a \to a)]} \\
        \transto{ ((\lambda x:(\Pi a:\star. \Pi b:\star. a \to b). f_1 (\lambda a:\star.  (\lambda x:(\Pi a:\star. \Pi b:\star. a \to b).  (\lambda x:(a \to a). x)\ (x\ a\ a) ) \ x) )\ (\castdowne x))}
    }
\]
\end{figure*}
%\end{landscape}

\fi
