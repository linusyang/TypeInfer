\section{type check}

\subsection{Syntax}
\gram{\ottt\ottinterrule
      \otte\ottinterrule
      \ottR\ottinterrule
      %\ottG\ottinterrule
  }
\\[2.0mm]

% \subsection{Operational Semantics}
% \ottdefnstep{}
% \ottusedrule{\ottdruleSXXMu{}}

\subsection{syntax-directed Typing}
% \ottdefnctx{}\ottinterrule
% \ottdefnexpr{}
% \ottusedrule{\ottdruleTXXMu{}}

\newcommand{\pgm}{\mathsf{P}}
\newcommand{\nat}{\mathsf{nat}}
\newcommand{\logic}{\mathsf{L}}
\newcommand{\judge}{\Gamma\vdash}

\newcommand{\checktype}{\Gamma\vdash_\Downarrow}
\newcommand{\infertype}{\Gamma\vdash_\Uparrow}
\newcommand{\infercheck}{\Gamma\vdash_\delta}

\newcommand{\checktypeno}{\vdash_\Downarrow}
\newcommand{\infertypeno}{\vdash_\Uparrow}
\newcommand{\infercheckno}{\vdash_\delta}

\newcommand{\instinfer}{\vdash^{inst}_\Uparrow}
\newcommand{\instcheck}{\vdash^{inst}_\Downarrow}
\newcommand{\instinfercheck}{\vdash^{inst}_\delta}

\newcommand{\polyinfer}{\vdash^{poly}_\Uparrow}
\newcommand{\polycheck}{\vdash^{poly}_\Downarrow}
\newcommand{\polyinfercheck}{\vdash^{poly}_\delta}

\newcommand{\polymorphic}{\vdash^{dsk}}
\newcommand{\polymorphicstar}{\vdash^{dsk\star}}

\newcommand{\substlet}{\textcolor{blue}{subst\_let}}

\newcommand{\forallvars}[1]{\forall \overbar{#1}}


\framebox{$ \judge e : \rho$ } infer $\Uparrow$ check $\Downarrow$ $\delta = \Uparrow \mid \Downarrow$

\[
\hl{$
\inferrule*[right=AX]
{} {\infercheck \star : \star}
$}
\]

\[
\inferrule*[right=Var]
{x:\sigma \in \Gamma \\ \instinfercheck \sigma \sqsubseteq \rho } {\infercheck x : \rho}
\]

\[
\inferrule*[right=Lam-Infer]
{\Gamma,x: \tau \infertypeno e : \rho} {\infertype (\lambda x.\, e) : (\Pi x: \tau. \rho)}
\]

\[
\inferrule*[right=Lam-Check]
{\Gamma,x: \sigma_1 \polycheck e : \sigma_2 } {\checktype (\lambda x.\, e) : (\Pi x: \sigma_1. \sigma_2)}
\]

\[
\inferrule*[right=LamAnn-Infer]
{
\hl{$\checktype \sigma:\star$} \\
\Gamma,x: \sigma \infertypeno e : \rho } {\infertype (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \rho)}
\]

\[
\inferrule*[right=LamAnn-Check]
{
\hl{$\checktype \sigma:\star$} \\
\polymorphic \sigma_1 \sqsubseteq \sigma \\ \Gamma,x: \sigma \polycheck e : \sigma_2 } {\checktype (\lambda x:\sigma.\, e) : (\Pi x: \sigma_1. \sigma_2)}
\]

\[
\inferrule*[right=App]
{\infertype e_1 : (\Pi x:\sigma_1. \sigma_2) \\
\polycheck e_2 : \sigma_1 \\
\instinfercheck \hl{$\sigma_2 [x \mapsto e_2]$} \sqsubseteq \rho}
{\infercheck e_1\,e_2 : \rho}
\]

\[
\hl{$
\inferrule*[right=ExplicitPi]
{\checktype \tau_1 : \star \\ \Gamma, x:\tau_1 \checktypeno \tau_2 : \star} {\infercheck (\Pi x:\tau_1. \tau_2) : \star}
$}
\]

\[
\inferrule*[right=Ann]
{
\hl{$\checktype \sigma : \star$} \\
\polycheck (e:\sigma) \\
\instinfercheck \sigma : \rho }
{\infercheck (e : \sigma) : \rho }
\]

\[
\hl{$
\inferrule*[right=CastUp-Check]
{ \rho_1 \longrightarrow \rho_2 \\ \checktype e : \rho_2 } {\checktype (\mathsf{cast}^\uparrow\ e) : \rho_1}
$}
\]

\[
\hl{$
\inferrule*[right=CastDown]
{\infertype e : \rho_1 \\ \rho_1 \longrightarrow \sigma \\ \instinfercheck \sigma \sqsubseteq \rho_2} {\infercheck (\mathsf{cast}_\downarrow\ e) : \rho_2}
$}
\]

\[
\inferrule*[right=Let]
{\polyinfer e_1 : \sigma \\
\hl{$\infercheck e_2[x \mapsto e_1]: \rho$}}
{\infercheck ( let\ x = e_1\ in\ e_2 ) : \rho }
\]

\framebox{$ \judge \sigma : \star$ }

\[
\hl{$
\inferrule*[right=ImplicitPi]
{\checktype \tau : \star \\ \Gamma, x:\tau \checktypeno \rho : \star} {\infercheck (\forall x : \tau. \rho) : \star}
$}
\]

\framebox{$ \judge \rho : \star$ }

\[
\hl{$
\inferrule*[right=FunPoly]
{\checktype \sigma_1 : \star \\ \Gamma, x:\sigma_1 \checktypeno \sigma_2 : \star} {\infercheck (\Pi x : \sigma_1. \sigma_2) : \star}
$}
\]

\framebox{$ \Gamma \polyinfercheck e : \sigma$ }

\[
\inferrule*[right=Gen-Infer]
{\infertype e :\rho \\ \overbar{x}=ftv(\rho)-ftv(\Gamma) \\
\hl{$\overbar{x:\tau}$} \\
\hl{$\checktype (\forallvars{x:\tau}. \rho):\star$} } {\polyinfer e :(\forallvars{x:\tau}. \rho)}
\]

\[
\inferrule*[right=Gen-Check]
{\overbar{x} \notin ftv(\Gamma) \\ \checktype e :\rho \\ pr(\sigma) = \forallvars{x:\tau} . \rho} {\polycheck e : \sigma}
\]

\framebox{$ \instinfercheck \sigma \sqsubseteq \rho$ }

\[
\inferrule*[right=Inst-Infer]
{\hl{$\overbar{\tau_\beta : \tau}$}}
{\instinfer \forallvars{x:\tau} . \rho \sqsubseteq \rho[\overbar{x \mapsto \tau_\beta}]}
\]

\[
\inferrule*[right=Inst-Check]
{\polymorphic \sigma \sqsubseteq \rho } {\instcheck \sigma \sqsubseteq \rho}
\]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\framebox{$pr(\sigma)=\forallvars{x:\tau}.\rho$: float out all $\forall$s, the same as the paper}

\[
\inferrule*[right=PR-POLY]
{pr(\rho_1) = \forallvars{b:\tau_2}. \rho_2 \\ \overbar{a} \cap \overbar{b} = \emptyset} {pr(\forallvars{a:\tau_1}. \rho_1) = \forallvars{a:\tau_1. b:\tau_2}. \rho_2}
\]

\[
\inferrule*[right=PR-FUN]
{pr(\sigma_2) = \forallvars{a:\tau}. \rho_2 \\ \overbar{a} \cap ftv(\sigma_1) = \emptyset} {pr(\Pi x:\sigma_1. \sigma_2) = \forallvars{a:\tau}. \Pi x:\sigma_1. \rho_2}
\]

\[
\inferrule*[right=\hl{PR-OTHER-CASE}]
{  } {pr(\tau)=\tau}
\]

\framebox{$\Sigma \polymorphic \sigma_1 \sqsubseteq \sigma_2$: almost same, take care of kinds}

\[
\inferrule*[right=DEEP-SKOL]
{pr(\sigma_2)=\forallvars{a:\tau}. \rho \\ a \notin ftv(\sigma_1) \\
\hl{$\Sigma \vdash \overbar{a:\tau}$} \\
\hl{$\Sigma, \overbar{a:\tau}$} \polymorphicstar \sigma_1 \sqsubseteq \rho }
{\Sigma \polymorphic \sigma_1 \sqsubseteq \sigma_2}
\]

\framebox{$\Sigma \polymorphicstar \sigma_1 \sqsubseteq \rho$}

\[
\inferrule*[right=SPEC]
{\hl{$\Sigma \vdash \overbar{\beta: \tau}$} \\
\hl{$\Sigma, \overbar{\beta:\tau}$} \polymorphicstar \rho_1[\overbar{a \mapsto \beta}] \sqsubseteq \rho_2}
{\Sigma \polymorphicstar \forallvars{a:\tau}.\rho_1 \sqsubseteq \rho_2}
\]

\[
\hl{$
\inferrule*[right=FUN]
{\Sigma \polymorphic  \sigma_3 \sqsubseteq \sigma_1 \\
\Sigma \vdash x:\sigma_1 \\
\Sigma, x:\sigma_1 \polymorphicstar  \rho_2 \sqsubseteq \rho_4}
{\Sigma \polymorphicstar \Pi x:\sigma_1. \rho_2 \sqsubseteq \Pi x:\sigma_3. \rho_4}
$}
\]

\[
\hl{$
\inferrule*[right=APP]
{
\Sigma \polymorphicstar  \tau_1 \sqsubseteq \tau_2}
{\Sigma \polymorphicstar \tau_1\, \sigma_1 \sqsubseteq \tau_2\, \sigma_1}
$}
\]

\[
\hl{$
\inferrule*[right=LAM]
{
\Sigma \polymorphic \sigma_2 \sqsubseteq \sigma_4}
{\Sigma \polymorphicstar \lambda x. \sigma_2 \sqsubseteq \lambda x. \sigma_4}
$}
\]

\[
\hl{$
\inferrule*[right=LAMANN]
{
\Sigma \vdash x:\sigma_1 \\
\Sigma, x:\sigma_1 \polymorphic \sigma_2 \sqsubseteq \sigma_4}
{\Sigma \polymorphicstar \lambda x:\sigma_1. \sigma_2 \sqsubseteq \lambda x:\sigma_1. \sigma_4}
$}
\]

\[
\hl{$
\inferrule*[right=ANN]
{
\Sigma \polymorphic  \sigma_1 \sqsubseteq \sigma_3}
{\Sigma \polymorphicstar \sigma_1:\sigma_2 \sqsubseteq \sigma_3:\sigma_2}
$}
\]

\[
\hl{$
\inferrule*[right=CASTUP]
{
\Sigma \polymorphic  \sigma_1 \sqsubseteq \sigma_2}
{\Sigma \polymorphicstar  (\mathsf{cast}^\uparrow\ \sigma_1) \sqsubseteq  (\mathsf{cast}^\uparrow\ \sigma_2)  }
$}
\]


\[
\hl{$
\inferrule*[right=CASTDOWN]
{
\Sigma \polymorphic  \sigma_1 \sqsubseteq \sigma_2}
{\Sigma \polymorphicstar  (\mathsf{cast}^\downarrow\ \sigma_1) \sqsubseteq  (\mathsf{cast}^\downarrow\ \sigma_2)  }
$}
\]

\[
\hl{$
\inferrule*[right=OTHER-CASE]
{  \alpha-equal(\sigma_1, \sigma_2)  }
{ \Sigma \polymorphicstar \sigma_1 \sqsubseteq \sigma_2}
$}
\]

\framebox{$\Sigma \vdash a: \tau$: two variable with same name should have same kind}

\[
\hl{$
\inferrule*[right=EXISTS]
{ a:\tau \in \Sigma}
{ \Sigma \vdash a:\tau}
$}
\]

\[
\hl{$
\inferrule*[right=NOT\_EXISTS]
{ b \notin \Sigma}
{ \Sigma \vdash b:\tau}
$}
\]

\begin{lstlisting}
unify ta tb =
    (t1, k1) = find(ta)
    (t2, k2) = find(tb)
    if t1 and t2 are both of form D p1 p2...
        unify(t1_pi, t2_pi)
    else if t1 is variable
        checktype t2 k1
        union(t1, t2)
    else if t2 is variable
        checktype t1 k2
        union(t1, t2)
    else if a-equal(t1, t2)
        done
    else
        error 'cannot unify ta and tb'
\end{lstlisting}
