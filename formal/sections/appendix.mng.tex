\section{type check}

\subsection{Syntax}
\gram{\otte\ottinterrule
      \ottS\ottinterrule
      \ottR\ottinterrule
      %\ottG\ottinterrule
  }
\\[2.0mm]

% \subsection{Operational Semantics}
% \ottdefnstep{}
% \ottusedrule{\ottdruleSXXMu{}}

\subsection{syntax-directed Typing}
% \ottdefnctx{}\ottinterrule
% \ottdefnexpr{}
% \ottusedrule{\ottdruleTXXMu{}}

\newcommand{\pgm}{\mathsf{P}}
\newcommand{\nat}{\mathsf{nat}}
\newcommand{\logic}{\mathsf{L}}
\newcommand{\judge}{\Gamma\vdash}

\newcommand{\checktype}{\Gamma\vdash_\Downarrow}
\newcommand{\infertype}{\Gamma\vdash_\Uparrow}
\newcommand{\infercheck}{\Gamma\vdash_\delta}

\newcommand{\checktypeno}{\vdash_\Downarrow}
\newcommand{\infertypeno}{\vdash_\Uparrow}
\newcommand{\infercheckno}{\vdash_\delta}

\newcommand{\instinfer}{\vdash^{inst}_\Uparrow}
\newcommand{\instcheck}{\vdash^{inst}_\Downarrow}
\newcommand{\instinfercheck}{\vdash^{inst}_\delta}

\newcommand{\polyinfer}{\vdash^{poly}_\Uparrow}
\newcommand{\polycheck}{\vdash^{poly}_\Downarrow}
\newcommand{\polyinfercheck}{\vdash^{poly}_\delta}

\newcommand{\polymorphic}{\vdash^{dsk}}
\newcommand{\polymorphicstar}{\vdash^{dsk\star}}

\newcommand{\substlet}{\textcolor{blue}{subst\_let}}


\framebox{$ \judge e : \rho$ } infer $\Uparrow$ check $\Downarrow$ $\delta = \Uparrow \mid \Downarrow$

\[
\hl{$
\inferrule*[right=AX]
{} {\infercheck \star : \star}
$}
\]

\[
\inferrule*[right=Var]
{x:\sigma \in \Gamma \\ \instinfercheck \sigma \sqsubseteq \rho } {\infercheck x : \rho}
\]

\[
\inferrule*[right=Lam-Infer]
{\Gamma,x: \tau \infertypeno e : \rho} {\infertype (\lambda x.\, e) : (\Pi x: \tau. \rho)}
\]

\[
\inferrule*[right=Lam-Check]
{\Gamma,x: \sigma_1 \polycheck e : \sigma_2 } {\checktype (\lambda x.\, e) : (\Pi x: \sigma_1. \sigma_2)}
\]

\[
\inferrule*[right=LamAnn-Infer]
{
\hl{$\checktype \sigma:\star$} \\
\Gamma,x: \sigma \infertypeno e : \rho } {\infertype (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \rho)}
\]

\[
\hl{$
\inferrule*[right=LamAnn-Check1]
{
\checktype \sigma:\star\\
\Gamma,x: \sigma \polycheck e : \sigma_2 } {\checktype (\lambda x:\sigma.\, e) : (\Pi x: \sigma. \sigma_2)}
$}
\]

\[
\hl{$
\inferrule*[right=LamAnn-Check2]
{
\checktype \sigma:\star \\
\polymorphic \sigma_1 \sqsubseteq \sigma \\ \Gamma,x: \sigma, y:\sigma_1 \polycheck e : \sigma_2 } {\checktype (\lambda x:\sigma.\, e) : (\Pi y: \sigma_1. \sigma_2)}
$}
\]

\[
\inferrule*[right=App]
{\infertype e_1 : (\Pi x:\sigma_1. \sigma_2) \\
\polycheck e_2 : \sigma_1 \\
\instinfercheck \hl{$\sigma_2 [x \mapsto e_2]$} \sqsubseteq \rho}
{\infercheck e_1\,e_2 : \rho}
\]

\[
\hl{$
\inferrule*[right=ExplicitPi]
{\checktype \tau_1 : \star \\ \Gamma, x:\tau_1 \checktypeno \tau_2 : \star} {\infercheck (\Pi x:\tau_1. \tau_2) : \star}
$}
\]

\[
\inferrule*[right=Ann]
{
\hl{$\checktype \sigma : \star$} \\
\polycheck (e:\sigma) \\
\instinfercheck \sigma : \rho }
{\infercheck (e : \sigma) : \rho }
\]

\[
\hl{$
\inferrule*[right=CastUp-Check]
{ \rho_1 \longrightarrow \rho_2 \\ \checktype e : \rho_2 } {\checktype (\mathsf{cast}^\uparrow\ e) : \rho_1}
$}
\]

\[
\hl{$
\inferrule*[right=CastDown]
{\infertype e : \rho_1 \\ \rho_1 \longrightarrow \sigma \\ \instinfercheck \sigma \sqsubseteq \rho_2} {\infercheck (\mathsf{cast}_\downarrow\ e) : \rho_2}
$}
\]

\[
\inferrule*[right=Let]
{\polyinfer e_1 : \sigma \\
\hl{$\infercheck e_2[x \mapsto e_1]: \rho$}}
{\infercheck ( let\ x = e_1\ in\ e_2 ) : \rho }
\]

\framebox{$ \judge \sigma : \star$ }

\[
\inferrule*[right=ImplicitPi]
{\checktype \tau : \star \\ \Gamma, x:\tau \checktypeno \rho : \star} {\infercheck (\forall x : \tau. \rho) : \star}
\]

\framebox{$ \judge \rho : \star$ }

\[
\inferrule*[right=FunPoly]
{\checktype \sigma_1 : \star \\ \Gamma, x:\sigma_1 \checktypeno \sigma_2 : \star} {\infercheck (\Pi x : \sigma_1. \sigma_2) : \star}
\]

\framebox{$ \Gamma \polyinfercheck e : \sigma$ }

\[
\inferrule*[right=Gen-Infer]
{\infertype e :\rho \\ x=ftv(\rho)-ftv(\Gamma) \\
\hl{$x:\tau$} \\
\hl{$\checktype (\forall x:\tau. \rho):\star$} } {\polyinfer e :(\forall x:\tau. \rho)}
\]

\[
\inferrule*[right=Gen-Check]
{x \notin ftv(\Gamma) \\ \checktype e :\rho \\ pr(\sigma) = \forall x: \tau. \rho} {\polycheck e : \sigma}
\]

\framebox{$ \instinfercheck \sigma \sqsubseteq \rho$ }

\[
\inferrule*[right=Inst-Infer]
{\hl{$\tau_\beta : \tau$}}
{\instinfer \forall x:\tau. \rho \sqsubseteq \rho[x \mapsto \tau_\beta]}
\]

\[
\inferrule*[right=Inst-Check]
{\polymorphic \sigma \sqsubseteq \rho } {\instcheck \sigma \sqsubseteq \rho}
\]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\framebox{$pr(\sigma)=\forall a:\tau.\rho$: float out all $\forall$s, the same as the paper}

\[
\inferrule*[right=PR-POLY]
{pr(\rho_1) = \forall b:\tau_2. \rho_2 \\ a \cap b = \emptyset} {pr(\forall a:\tau_1. \rho_1) = \forall a:\tau_1. \forall b:\tau_2. \rho_2}
\]

\[
\inferrule*[right=PR-FUN]
{pr(\sigma_2) = \forall a:\tau. \rho_2 \\ a \cap ftv(\sigma_1) = \emptyset} {pr(\Pi x:\sigma_1. \sigma_2) = \forall a:\tau_1. \Pi x:\sigma_1. \rho_2}
\]

\[
\inferrule*[right=\hl{PR-OTHER-CASE}]
{  } {pr(\tau)=\tau}
\]

\framebox{$\Sigma \polymorphic \sigma_1 \sqsubseteq \sigma_2$: almost same, take care of kinds}

\[
\inferrule*[right=DEEP-SKOL]
{pr(\sigma_2)=\forall a:\tau. \rho \\ a \notin ftv(\sigma_1) \\
\hl{$a \notin ftv(\Sigma)$} \\
\hl{$\Sigma, a:\tau$} \polymorphicstar \sigma_1 \sqsubseteq \rho }
{\Sigma \polymorphic \sigma_1 \sqsubseteq \sigma_2}
\]

\framebox{$\Sigma \polymorphicstar \sigma_1 \sqsubseteq \rho$}

\[
\inferrule*[right=SPEC]
{\hl{$\Sigma \vdash \beta: \tau$} \\
\hl{$\Sigma, \beta:\tau$} \polymorphicstar \rho_1[a \mapsto \beta] \sqsubseteq \rho_2}
{\Sigma \polymorphicstar \forall a:\tau.\rho_1 \sqsubseteq \rho_2}
\]

\[
\hl{$
\inferrule*[right=FUN1]
{
\Sigma, x:\sigma_1 \polymorphicstar  \sigma_2 \sqsubseteq \sigma_4}
{\Sigma \polymorphicstar \Pi x:\sigma_1. \sigma_2 \sqsubseteq \Pi x:\sigma_1. \sigma_4}
$}
\]

\[
\hl{$
\inferrule*[right=FUN2]
{\Sigma \polymorphic  \sigma_3 \sqsubseteq \sigma_1 \\
\Sigma, x:\sigma_1, y:\sigma_3 \polymorphicstar  \sigma_2 \sqsubseteq \sigma_4}
{\Sigma \polymorphicstar \Pi x:\sigma_1. \sigma_2 \sqsubseteq \Pi y:\sigma_3. \sigma_4}
$}
\]

\[
\inferrule*[right=MONO]
{\hl{$ \tau \in \Sigma$}}
{\Sigma \polymorphicstar \tau \sqsubseteq \tau}
\]

\[
\hl{$
\inferrule*[right=OTHER-CASE]
{  \alpha-equal(\sigma_1, \sigma_2)  }
{ \Sigma \polymorphicstar \sigma_1 \sqsubseteq \sigma_2}
$}
\]

\framebox{$\Sigma \vdash a: \tau$: in order to use dsk*-mono, two variable with same name should have same kind}

\[
\hl{$
\inferrule*[right=EXISTS]
{ a:\tau \in \Sigma}
{ \Sigma \vdash a:\tau}
$}
\]

\[
\hl{$
\inferrule*[right=NOT\_EXISTS]
{ b \notin \Sigma}
{ \Sigma \vdash b:\tau}
$}
\]

